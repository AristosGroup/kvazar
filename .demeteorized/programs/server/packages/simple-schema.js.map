{"version":3,"file":"/packages/simple-schema.js","sources":["simple-schema/mongo-object.js","simple-schema/simple-schema.js","simple-schema/simple-schema-context.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA,E;AACA,e;AACA,gC;AACA,uB;AACA,G;AACA,uC;AACA,kB;AACA,4B;AACA,0B;AACA,iC;;AAEA,4E;;AAEA,gD;AACA,0E;AACA,6B;AACA,yB;AACA,K;;AAEA,sB;;AAEA,uC;AACA,2H;AACA,2B;AACA,sE;AACA,oE;AACA,oE;AACA,mD;AACA,0B;AACA,wD;AACA,gB;AACA,2C;AACA,S;AACA,wB;AACA,O;;AAEA,8G;AACA,0D;AACA,8E;AACA,O;AACA,K;;AAEA,0B;AACA,yB;AACA,kC;AACA,wH;AACA,S;AACA,K;;AAEA,+B;AACA,kC;AACA,kC;AACA,6B;AACA,sI;AACA,S;AACA,S;AACA,K;;AAEA,G;AACA,0B;;AAEA,uH;AACA,yB;AACA,oC;AACA,2C;AACA,E;AACA,2D;AACA,mG;AACA,0D;AACA,8E;AACA,O;AACA,E;AACA,gC;AACA,4B;AACA,uD;AACA,qC;AACA,yC;AACA,kB;AACA,uE;AACA,W;AACA,yB;AACA,0E;AACA,iC;AACA,kC;AACA,+E;AACA,sC;AACA,oB;AACA,S;AACA,O;AACA,E;AACA,4B;AACA,6B;AACA,8B;AACA,wC;AACA,8C;AACA,2C;AACA,8C;AACA,+E;AACA,oB;AACA,6E;AACA,a;AACA,mC;AACA,uC;AACA,6F;AACA,qC;AACA,uE;AACA,iF;AACA,qE;AACA,sF;AACA,2H;AACA,wB;AACA,a;AACA,S;AACA,O;AACA,K;AACA,oB;;AAEA,mG;AACA,+B;AACA,+B;AACA,gD;AACA,uF;AACA,iF;AACA,qC;AACA,mC;AACA,yD;AACA,gE;AACA,iB;AACA,uC;AACA,qD;AACA,U;AACA,4B;AACA,gD;AACA,S;AACA,yG;AACA,O;AACA,I;;AAEA,iD;AACA,mE;AACA,uD;AACA,0B;AACA,qD;AACA,qC;AACA,qC;AACA,O;AACA,gC;AACA,uE;AACA,e;AACA,O;AACA,K;AACA,mB;AACA,I;;AAEA,wD;AACA,8E;AACA,uD;AACA,0B;AACA,qD;AACA,qC;AACA,qC;AACA,O;AACA,yB;AACA,gC;AACA,oD;AACA,6B;AACA,iC;AACA,c;AACA,yC;AACA,6C;AACA,qC;AACA,8C;AACA,uD;AACA,S;AACA,kC;AACA,yE;AACA,iB;AACA,S;AACA,O;AACA,K;AACA,I;;AAEA,oD;AACA,qE;AACA,yD;AACA,4B;AACA,uD;AACA,uC;AACA,uC;AACA,S;AACA,2B;AACA,iC;AACA,gB;AACA,oC;AACA,2E;AACA,mB;AACA,W;AACA,S;AACA,O;;AAEA,iC;AACA,8C;AACA,wD;AACA,gD;AACA,8C;AACA,uC;AACA,S;AACA,O;AACA,K;;AAEA,qE;AACA,oE;AACA,kC;AACA,yB;AACA,I;;AAEA,8D;AACA,6B;AACA,2C;AACA,qB;AACA,qC;AACA,8C;AACA,wD;AACA,mD;AACA,kE;AACA,iD;AACA,0D;AACA,8C;AACA,2B;AACA,oB;AACA,uB;AACA,gG;AACA,c;AACA,W;AACA,S;AACA,O;AACA,K;AACA,I;;AAEA,uD;AACA,uC;AACA,8C;AACA,wD;AACA,mD;AACA,wD;AACA,0D;AACA,yD;AACA,4D;AACA,oD;AACA,S;AACA,O;AACA,K;AACA,I;;AAEA,oE;AACA,sC;AACA,8C;AACA,wD;AACA,mD;AACA,wD;AACA,0D;AACA,0D;AACA,mE;AACA,4E;AACA,kB;AACA,sD;AACA,8F;AACA,Y;AACA,S;AACA,O;AACA,K;AACA,I;;AAEA,4B;AACA,wC;AACA,4B;AACA,iC;AACA,sC;AACA,Y;AACA,iC;AACA,2D;AACA,sB;AACA,kC;AACA,gB;AACA,+C;AACA,S;AACA,O;AACA,K;;AAEA,4C;AACA,uC;AACA,2D;AACA,I;;AAEA,sC;AACA,yC;AACA,qD;AACA,+D;AACA,0D;AACA,gD;AACA,S;AACA,O;AACA,K;AACA,I;;AAEA,0C;AACA,kC;AACA,8C;AACA,wD;AACA,mD;AACA,gD;AACA,S;AACA,O;AACA,K;AACA,I;;AAEA,2C;AACA,oC;AACA,oD;AACA,8B;AACA,K;AACA,I;;AAEA,uD;AACA,iE;AACA,2C;AACA,6B;AACA,qD;AACA,+D;AACA,iD;AACA,2C;AACA,+B;AACA,gC;AACA,sC;AACA,W;AACA,S;AACA,O;AACA,K;AACA,I;;AAEA,oD;AACA,4C;AACA,8C;AACA,wD;AACA,mD;AACA,kD;AACA,S;AACA,O;AACA,K;AACA,I;;AAEA,gD;AACA,mD;AACA,qD;AACA,+D;AACA,0D;AACA,kD;AACA,S;AACA,O;AACA,K;AACA,I;;AAEA,2D;AACA,+B;AACA,qB;AACA,I;;AAEA,mC;AACA,oB;AACA,gE;AACA,kF;AACA,O;AACA,uB;AACA,I;;AAEA,0D;AACA,0E;AACA,yE;AACA,c;AACA,mC;AACA,oB;AACA,gE;AACA,4C;AACA,iE;AACA,O;AACA,O;AACA,kB;AACA,I;;AAEA,mE;AACA,mC;AACA,8C;AACA,wD;AACA,mD;AACA,sB;AACA,S;AACA,O;AACA,K;AACA,iB;AACA,I;;AAEA,+D;AACA,0C;AACA,qD;AACA,+D;AACA,0D;AACA,sB;AACA,S;AACA,O;AACA,K;AACA,iB;AACA,I;;AAEA,4E;AACA,kD;AACA,qD;AACA,+D;AACA,8D;;AAEA,8C;AACA,kC;AACA,sB;AACA,S;;AAEA,4E;AACA,wD;AACA,qE;AACA,sB;AACA,S;;AAEA,4E;AACA,mE;AACA,oC;AACA,mE;AACA,sB;AACA,S;AACA,O;AACA,K;AACA,iB;AACA,I;AACA,E;;AAEA,gE;AACA,0D;AACA,I;AACA,yC;AACA,mB;AACA,2B;AACA,gC;AACA,qC;AACA,G;;AAEA,gE;AACA,0D;AACA,I;AACA,yC;AACA,mB;AACA,2B;AACA,gC;AACA,qC;AACA,G;AACA,mB;AACA,sB;AACA,sB;AACA,uB;AACA,G;AACA,iD;AACA,iE;AACA,qD;AACA,wB;AACA,mC;AACA,mC;AACA,K;AACA,uB;AACA,+D;AACA,4B;AACA,gD;AACA,yB;AACA,+B;AACA,Y;AACA,yC;AACA,iC;AACA,0C;AACA,6B;AACA,qD;AACA,O;AACA,K;AACA,8B;AACA,G;AACA,E;;AAEA,8C;AACA,6C;AACA,E;;AAEA,8B;AACA,6B;AACA,E;;AAEA,0B;AACA,kD;AACA,yC;AACA,8C;AACA,8B;AACA,M;AACA,U;AACA,8C;AACA,4D;AACA,0C;AACA,M;AACA,G;AACA,C;;AAEA,iD;AACA,sC;AACA,G;AACA,mB;AACA,qB;AACA,G;AACA,mC;AACA,0E;AACA,E;;AAEA,6D;AACA,gE;AACA,mC;AACA,G;AACA,qB;AACA,wB;AACA,G;AACA,kC;AACA,+B;AACA,gB;AACA,uE;AACA,E;;AAEA,oD;AACA,wB;AACA,uB;AACA,U;AACA,yD;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;AC9hBA,uD;AACA,wC;;AAEA,sB;AACA,4B;AACA,C;AACA,sB;AACA,e;AACA,C;;AAEA,U;AACA,e;AACA,+F;AACA,0e;AACA,E;;AAEA,uB;AACA,kC;AACA,yD;AACA,sD;AACA,8C;AACA,2C;AACA,gD;AACA,2C;AACA,0D;AACA,6D;AACA,0C;AACA,gD;AACA,6C;AACA,6C;AACA,+C;AACA,4C;AACA,8C;AACA,kD;AACA,wD;AACA,wD;AACA,E;;AAEA,yB;;AAEA,U;AACA,0C;AACA,sE;AACA,2E;AACA,iE;AACA,0B;AACA,gE;AACA,8B;AACA,gD;AACA,wB;AACA,8C;AACA,mC;;AAEA,kC;AACA,0B;AACA,oB;AACA,kC;AACA,sC;AACA,6D;AACA,6D;AACA,qC;AACA,qC;AACA,+C;AACA,6C;AACA,qC;AACA,wD;AACA,I;;AAEA,6E;AACA,wD;AACA,8D;;AAEA,0B;AACA,8C;;AAEA,kD;AACA,oC;AACA,oD;AACA,yE;AACA,K;;AAEA,4C;;AAEA,qC;;AAEA,2D;AACA,+C;AACA,iC;AACA,yD;AACA,O;AACA,M;AACA,sC;AACA,+D;AACA,O;AACA,K;;AAEA,+B;AACA,yC;AACA,K;AACA,I;AACA,oC;AACA,+C;AACA,K;AACA,K;;AAEA,sB;AACA,gD;AACA,oD;AACA,oE;AACA,uE;AACA,4D;AACA,gF;AACA,mF;;AAEA,iD;AACA,gC;AACA,E;;AAEA,0E;AACA,iB;AACA,gD;AACA,qC;AACA,E;;AAEA,2B;AACA,sF;AACA,6B;AACA,2C;;AAEA,qF;AACA,2E;AACA,kD;AACA,kB;AACA,E;AACA,uC;AACA,gC;AACA,kC;AACA,sC;AACA,wB;AACA,Y;AACA,2B;AACA,G;AACA,K;;AAEA,kC;AACA,2F;;AAEA,kG;AACA,6E;AACA,E;AACA,c;AACA,E;;AAEA,sD;AACA,kB;AACA,iC;AACA,qB;AACA,G;AACA,6G;AACA,wC;AACA,E;;AAEA,mD;AACA,8B;AACA,E;;AAEA,wC;AACA,uD;AACA,kB;;AAEA,uD;AACA,sB;AACA,iB;AACA,qB;AACA,oB;;AAEA,sD;AACA,0B;AACA,gC;AACA,qC;AACA,gD;AACA,4D;AACA,qE;AACA,4D;AACA,O;AACA,0B;AACA,K;AACA,G;;AAEA,kC;;AAEA,2D;AACA,6B;AACA,iE;AACA,sC;AACA,K;;AAEA,oD;AACA,oG;AACA,6B;AACA,iD;AACA,0D;AACA,K;AACA,K;AACA,E;AACA,0B;AACA,E;;AAEA,sE;AACA,iB;AACA,+C;AACA,kB;AACA,Y;AACA,6B;AACA,U;AACA,wB;AACA,G;AACA,E;;AAEA,sD;AACA,kH;AACA,qC;AACA,E;;AAEA,+C;AACA,kD;AACA,kB;AACA,6C;AACA,kC;AACA,a;;AAEA,qC;AACA,a;;AAEA,6C;AACA,K;AACA,E;;AAEA,sE;AACA,yE;AACA,0E;AACA,gH;AACA,+B;AACA,iD;AACA,yC;AACA,G;AACA,oE;AACA,4B;AACA,wE;AACA,G;AACA,e;AACA,sC;AACA,uC;AACA,yD;AACA,4C;AACA,0D;AACA,G;AACA,4C;AACA,0D;AACA,G;AACA,2C;AACA,2D;AACA,G;AACA,oB;AACA,oB;AACA,kC;AACA,gB;AACA,G;AACA,kC;AACA,gB;AACA,G;AACA,iD;AACA,qC;AACA,gE;AACA,K;AACA,qC;AACA,gE;AACA,K;AACA,U;AACA,qC;AACA,8C;AACA,K;AACA,qC;AACA,8C;AACA,K;AACA,G;AACA,qC;AACA,uD;AACA,G;AACA,iB;AACA,E;;AAEA,qE;AACA,oC;AACA,wE;AACA,kD;AACA,iD;;AAEA,wC;AACA,sB;;AAEA,wC;AACA,mE;AACA,8B;;AAEA,uD;AACA,4B;AACA,qB;AACA,Y;AACA,K;;AAEA,oE;AACA,mE;AACA,+D;AACA,qB;AACA,Y;AACA,K;;AAEA,oE;AACA,8E;AACA,gC;AACA,6D;AACA,qB;AACA,Y;AACA,K;AACA,G;;AAEA,iB;AACA,E;;AAEA,gD;AACA,iD;AACA,E;;AAEA,iE;AACA,kB;AACA,mB;AACA,8C;AACA,G;AACA,yD;AACA,E;;AAEA,wD;AACA,kC;AACA,E;;AAEA,0D;AACA,oC;AACA,E;;AAEA,uE;AACA,kB;AACA,mB;AACA,oD;AACA,G;AACA,+D;AACA,E;;AAEA,8D;AACA,wC;AACA,E;;AAEA,mB;AACA,yC;AACA,wB;AACA,sF;AACA,8B;AACA,K;AACA,iB;AACA,G;AACA,wB;AACA,oC;AACA,iD;AACA,uC;AACA,6B;AACA,wB;AACA,c;AACA,0D;AACA,O;AACA,K;AACA,iB;AACA,G;AACA,e;AACA,E;;AAEA,gF;AACA,mC;AACA,4E;AACA,E;;AAEA,mC;AACA,wB;AACA,iE;AACA,kB;AACA,K;AACA,G;AACA,e;AACA,E;;AAEA,uC;AACA,mC;AACA,e;AACA,gB;AACA,G;AACA,4B;AACA,e;AACA,gB;AACA,G;AACA,mD;AACA,E;;AAEA,qC;AACA,uD;AACA,0B;AACA,0B;AACA,iC;AACA,0D;AACA,sD;AACA,O;AACA,0B;AACA,G;;AAEA,uD;AACA,qC;AACA,kB;AACA,6C;AACA,gB;AACA,sB;AACA,wB;AACA,sD;AACA,kB;AACA,yB;AACA,0B;AACA,Y;AACA,a;AACA,K;AACA,mD;AACA,mD;AACA,sC;AACA,8B;AACA,gC;AACA,O;AACA,K;AACA,gB;AACA,E;;AAEA,G;AACA,qB;AACA,yE;AACA,0E;AACA,yB;AACA,oC;AACA,G;AACA,wC;AACA,wE;;AAEA,qB;AACA,6C;AACA,uC;;AAEA,wB;AACA,6C;AACA,sD;AACA,yD;AACA,kC;AACA,sC;AACA,gB;AACA,uC;AACA,S;AACA,O;AACA,8C;AACA,K;AACA,K;;AAEA,4D;AACA,4B;AACA,2B;AACA,qD;AACA,K;AACA,G;;AAEA,6D;AACA,6B;AACA,2B;AACA,mD;AACA,K;AACA,G;;AAEA,oB;AACA,6C;AACA,8B;AACA,mD;AACA,uC;AACA,iC;AACA,6B;AACA,O;AACA,sC;AACA,yC;AACA,sB;AACA,0C;AACA,O;AACA,sC;AACA,2C;AACA,sC;AACA,O;AACA,2C;AACA,sC;AACA,O;AACA,qD;AACA,0D;AACA,O;AACA,sD;AACA,4D;AACA,O;AACA,+C;AACA,8C;AACA,O;AACA,6C;AACA,0C;AACA,O;AACA,8C;AACA,uB;AACA,iG;AACA,gC;AACA,S;AACA,K;AACA,K;;AAEA,4D;AACA,4B;AACA,2B;AACA,qD;AACA,K;AACA,G;;AAEA,6D;AACA,6B;AACA,2B;AACA,mD;AACA,K;AACA,G;;AAEA,gB;AACA,E;;AAEA,kD;AACA,0B;AACA,qD;AACA,sD;AACA,kD;AACA,qC;AACA,c;AACA,kC;AACA,Y;AACA,a;AACA,K;;AAEA,mB;AACA,gD;AACA,gD;AACA,+D;AACA,gD;AACA,wC;AACA,S;AACA,O;AACA,O;AACA,iC;AACA,K;AACA,e;AACA,E;;AAEA,kB;AACA,sC;AACA,0B;AACA,kB;;AAEA,wB;AACA,kD;AACA,+C;AACA,2C;AACA,a;AACA,K;;AAEA,+D;AACA,4B;AACA,8C;AACA,0B;AACA,uC;AACA,oC;AACA,O;AACA,K;AACA,6C;AACA,yC;AACA,K;;AAEA,sB;AACA,E;;AAEA,2C;AACA,mB;AACA,oB;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;AC1lBA,E;AACA,a;AACA,G;;AAEA,8C;AACA,kB;AACA,0B;AACA,6B;AACA,0C;AACA,yB;AACA,kC;AACA,kB;AACA,sC;AACA,2C;AACA,2C;AACA,K;AACA,E;;AAEA,2F;AACA,2E;AACA,kB;AACA,sB;AACA,oB;AACA,iB;AACA,oB;;AAEA,a;AACA,+C;;AAEA,kG;;AAEA,iD;;AAEA,uE;AACA,gF;AACA,uD;;AAEA,U;AACA,kC;;AAEA,yC;AACA,qD;;AAEA,oC;AACA,oD;AACA,sC;AACA,wC;AACA,oC;AACA,wC;AACA,K;AACA,K;AACA,2B;AACA,4B;AACA,G;;AAEA,yD;AACA,wC;AACA,E;;AAEA,2F;AACA,uF;AACA,kB;AACA,sB;AACA,mB;AACA,oB;;AAEA,a;AACA,+C;;AAEA,qG;;AAEA,iD;;AAEA,8D;AACA,0B;AACA,kE;AACA,6B;AACA,6B;AACA,6B;AACA,K;AACA,G;AACA,qC;;AAEA,4C;AACA,4D;AACA,uB;AACA,8B;AACA,G;;AAEA,oG;AACA,yC;AACA,kC;AACA,sC;AACA,G;AACA,0B;;AAEA,yD;AACA,sC;AACA,E;;AAEA,6B;AACA,sE;AACA,kB;AACA,uD;AACA,yB;AACA,sC;AACA,wC;AACA,oC;AACA,wC;AACA,K;AACA,K;AACA,E;;AAEA,8D;AACA,kB;AACA,yB;AACA,mC;AACA,E;;AAEA,kE;AACA,kB;AACA,yB;AACA,2B;AACA,E;;AAEA,qF;AACA,kB;AACA,iD;AACA,yE;AACA,kH;AACA,+C;AACA,E;;AAEA,uE;AACA,mD;AACA,mC;AACA,+C;AACA,E;;AAEA,0E;AACA,mD;AACA,mC;AACA,8D;AACA,kB;AACA,mE;AACA,G;AACA,0C;AACA,E;;AAEA,E;AACA,U;AACA,G;;AAEA,2E;AACA,E;AACA,4E;AACA,yB;AACA,2F;AACA,G;AACA,E;AACA,mB;AACA,yB;AACA,6G;AACA,Y;AACA,8D;AACA,2C;AACA,S;AACA,iC;AACA,0G;AACA,O;AACA,K;AACA,sC;AACA,qH;AACA,G;;AAEA,iE;AACA,sE;AACA,mD;AACA,4D;AACA,sE;AACA,mD;AACA,8B;AACA,mB;AACA,gC;AACA,sD;AACA,K;AACA,4B;AACA,G;AACA,E;AACA,uB;;AAEA,qD;AACA,oE;;AAEA,uE;AACA,e;AACA,iF;AACA,a;AACA,K;;AAEA,oE;AACA,+E;AACA,6D;AACA,uE;AACA,6D;AACA,4D;AACA,wB;AACA,+E;AACA,8E;AACA,e;AACA,O;AACA,K;;AAEA,wE;AACA,4E;AACA,2E;AACA,a;AACA,K;;AAEA,mE;AACA,gC;AACA,8E;AACA,M;AACA,uB;;AAEA,kD;AACA,mD;AACA,wB;AACA,8E;AACA,iB;AACA,S;;AAEA,kD;AACA,uE;AACA,iF;AACA,iB;AACA,S;AACA,M;AACA,O;;AAEA,kD;AACA,oE;AACA,+E;AACA,e;AACA,O;;AAEA,K;;AAEA,gC;AACA,iD;AACA,kE;AACA,0C;AACA,4E;AACA,qB;AACA,O;AACA,kB;AACA,O;AACA,G;;AAEA,2B;AACA,2D;AACA,gC;AACA,I;AACA,gD;AACA,0E;AACA,6B;AACA,yB;AACA,K;;AAEA,sB;;AAEA,uC;AACA,6E;AACA,2B;AACA,sE;AACA,oE;AACA,oE;AACA,mD;AACA,0B;AACA,gB;AACA,2C;AACA,S;AACA,wB;AACA,O;;AAEA,iE;AACA,wC;AACA,oD;AACA,0C;;AAEA,wC;AACA,oG;AACA,sE;AACA,O;AACA,K;;AAEA,2D;AACA,2D;AACA,wC;AACA,gD;AACA,e;AACA,K;;AAEA,0B;AACA,yB;AACA,kC;AACA,+D;AACA,S;AACA,K;AACA,I;AACA,+B;AACA,kC;AACA,M;AACA,iC;AACA,oC;AACA,M;AACA,4E;AACA,sD;AACA,2C;AACA,8H;AACA,iE;AACA,Q;AACA,sD;AACA,2B;AACA,4D;AACA,qD;AACA,2D;AACA,a;AACA,W;AACA,O;AACA,M;AACA,kH;AACA,M;AACA,0E;AACA,sE;AACA,uE;AACA,6E;;AAEA,O;AACA,M;AACA,wB;AACA,2F;AACA,M;AACA,0C;AACA,yC;AACA,+B;AACA,sF;AACA,S;AACA,S;AACA,K;AACA,I;AACA,G;AACA,E;AACA,4B;AACA,gB;;AAEA,oD;AACA,2B;AACA,wD;AACA,oD;AACA,wC;AACA,kB;AACA,K;AACA,iB;AACA,K;;AAEA,qB;AACA,E;;AAEA,gD;AACA,8B;;AAEA,wC;AACA,oB;AACA,oB;AACA,kC;AACA,gB;AACA,G;AACA,kC;AACA,gB;AACA,G;;AAEA,kB;AACA,gC;AACA,uC;AACA,8B;AACA,uD;AACA,yB;AACA,uD;AACA,yB;AACA,0E;AACA,qB;AACA,sC;AACA,qB;AACA,0C;AACA,iC;AACA,oC;AACA,uB;AACA,S;AACA,oB;AACA,S;AACA,qB;AACA,0B;AACA,K;AACA,G;;AAEA,kB;AACA,qC;AACA,uC;AACA,8B;AACA,iE;AACA,yB;AACA,iE;AACA,yB;AACA,uE;AACA,yB;AACA,K;AACA,G;;AAEA,mB;AACA,sC;AACA,wC;AACA,+B;AACA,K;AACA,G;;AAEA,kB;AACA,qC;AACA,mC;AACA,8B;AACA,K;AACA,G;;AAEA,iB;AACA,oC;AACA,+B;AACA,6B;AACA,yE;AACA,wB;AACA,yE;AACA,wB;AACA,K;AACA,G;;AAEA,gC;AACA,4E;;AAEA,iC;AACA,8C;AACA,mC;AACA,K;;AAEA,kB;AACA,qC;AACA,gE;AACA,yB;AACA,uE;AACA,yB;AACA,O;AACA,K;AACA,G;;AAEA,E;;AAEA,E;AACA,U;AACA,G;;AAEA,oD;AACA,wB;AACA,uB;AACA,U;AACA,yD;AACA,G;AACA,E;;AAEA,iC;AACA,2B;AACA,oE;AACA,G;AACA,mE;AACA,E;;AAEA,6B;AACA,gC;AACA,iB;AACA,G;AACA,6B;AACA,E;;AAEA,4C;AACA,0D;AACA,E;;AAEA,mE;AACA,0G;AACA,E;;AAEA,iF;AACA,mC;AACA,4E;AACA,E;;AAEA,2E;AACA,yB;AACA,mC;AACA,mE;AACA,yE;AACA,yE;AACA,sF;AACA,E;;AAEA,2B;AACA,wC;AACA,E;;AAEA,kC;AACA,+B;AACA,gB;;AAEA,uE;AACA,E","sourcesContent":["/*\n * @constructor\n * @param {Object} objOrModifier\n * @returns {undefined}\n */\nMongoObject = function(objOrModifier) {\n  var self = this;\n  self._obj = objOrModifier;\n  self._affectedKeys = {};\n  self._genericAffectedKeys = {};\n\n  function parseObj(val, currentPosition, affectedKey, operator, adjusted) {\n\n    // Adjust for first-level modifier operators\n    if (!operator && affectedKey && affectedKey.substring(0, 1) === \"$\") {\n      operator = affectedKey;\n      affectedKey = null;\n    }\n\n    if (affectedKey) {\n\n      // Adjust for $push and $addToSet\n      if (!adjusted && (operator === \"$push\" || operator === \"$addToSet\" || operator === \"$pull\" || operator === \"$pop\")) {\n        // Adjust for $each\n        // We can simply jump forward and pretend like the $each array\n        // is the array for the field. This has the added benefit of\n        // skipping past any $slice, which we also don't care about.\n        if (isBasicObject(val) && \"$each\" in val) {\n          val = val.$each;\n          currentPosition = currentPosition + \"[$each]\";\n        } else {\n          affectedKey = affectedKey + \".0\";\n        }\n        adjusted = true;\n      }\n\n      if (currentPosition && (!isBasicObject(val) || _.isEmpty(val)) && (!_.isArray(val) || _.isEmpty(val))) {\n        self._affectedKeys[currentPosition] = affectedKey;\n        self._genericAffectedKeys[currentPosition] = makeGeneric(affectedKey);\n      }\n    }\n\n    // Loop through arrays\n    if (_.isArray(val)) {\n      _.each(val, function(v, i) {\n        parseObj(v, (currentPosition ? currentPosition + \"[\" + i + \"]\" : i), affectedKey + '.' + i, operator, adjusted);\n      });\n    }\n\n    // Loop through object keys\n    else if (isBasicObject(val)) {\n      _.each(val, function(v, k) {\n        if (k !== \"$slice\") {\n          parseObj(v, (currentPosition ? currentPosition + \"[\" + k + \"]\" : k), appendAffectedKey(affectedKey, k), operator, adjusted);\n        }\n      });\n    }\n\n  }\n  parseObj(objOrModifier);\n\n//  (function recurse(obj, currentPosition, affectedKey, isUnderOperator, isUnderEachOrPullAll, isUnderArrayOperator) {\n//    var newAffectedKey;\n//    var objIsArray = isArray(obj);\n//    var objIsObject = isBasicObject(obj);\n//\n//    //store values, affectedKeys, and genericAffectedKeys\n//    if (currentPosition && (!objIsObject || _.isEmpty(obj)) && (!objIsArray || _.isEmpty(obj))) {\n//      self._affectedKeys[currentPosition] = affectedKey;\n//      self._genericAffectedKeys[currentPosition] = makeGeneric(affectedKey);\n//    }\n//\n//    //loop through array items\n//    else if (objIsArray) {\n//      for (var i = 0, ln = obj.length; i < ln; i++) {\n//        if (isUnderEachOrPullAll) {\n//          newAffectedKey = affectedKey;\n//        } else {\n//          newAffectedKey = (affectedKey ? affectedKey + \".\" + i : i);\n//        }\n//        recurse(obj[i],\n//                (currentPosition ? currentPosition + \"[\" + i + \"]\" : i),\n//                newAffectedKey,\n//                isUnderOperator,\n//                null, // Only the first array needs to be treated differently\n//                isUnderArrayOperator\n//                );\n//      }\n//    }\n//\n//    //recurse into objects\n//    else if (objIsObject) {\n//      for (var key in obj) {\n//        if (obj.hasOwnProperty(key)) {\n//          if (key.substring(0, 1) === \"$\") {\n//            newAffectedKey = affectedKey;\n//          } else if (isUnderArrayOperator) {\n//            newAffectedKey = (affectedKey ? affectedKey + \".$.\" + key : key);\n//          } else {\n//            newAffectedKey = (affectedKey ? affectedKey + \".\" + key : key);\n//          }\n//          if (key !== \"$slice\") {\n//            recurse(obj[key], //value\n//                    (currentPosition ? currentPosition + \"[\" + key + \"]\" : key), //position\n//                    newAffectedKey,\n//                    (isUnderOperator || key.substring(0, 1) === \"$\"),\n//                    // For $each and $pullAll, the first array we come to after\n//                    // the operator needs to be treated differently\n//                    (isUnderEachOrPullAll || key === \"$each\" || key === \"$pullAll\"),\n//                    (isUnderArrayOperator || key === \"$push\" || key === \"$addToSet\" || key === \"$pull\" || key === \"$pop\")\n//                    );\n//          }\n//      }\n//    }\n//  }\n//})(objOrModifier);\n\n  // Runs a function for each endpoint node in the object tree, including all items in every array.\n  // The function arguments are\n  // (1) the value at this node\n  // (2) a string representing the node position\n  // (3) the representation of what would be changed in mongo, using mongo dot notation\n  // (4) the generic equivalent of argument 3, with \"$\" instead of numeric pieces\n  self.forEachNode = function(func) {\n    if (typeof func !== \"function\")\n      throw new Error(\"filter requires a loop function\");\n    _.each(self._affectedKeys, function(affectedKey, position) {\n      func.call({\n        updateValue: function(newVal) {\n          self.setValueForPosition(position, newVal);\n        },\n        remove: function() {\n          self.removeValueForPosition(position);\n        }\n      }, self.getValueForPosition(position), position, affectedKey, self._genericAffectedKeys[position]);\n    });\n  };\n\n  self.getValueForPosition = function(position) {\n    var subkey, subkeys = position.split(\"[\"), current = self._obj;\n    for (var i = 0, ln = subkeys.length; i < ln; i++) {\n      subkey = subkeys[i];\n      // If the subkey ends in \"]\", remove the ending\n      if (subkey.slice(-1) === \"]\") {\n        subkey = subkey.slice(0, -1);\n      }\n      current = current[subkey];\n      if (!isArray(current) && !isBasicObject(current) && i < ln - 1) {\n        return;\n      }\n    }\n    return current;\n  };\n\n  self.setValueForPosition = function(position, value) {\n    var nextPiece, subkey, subkeys = position.split(\"[\"), current = self._obj;\n    for (var i = 0, ln = subkeys.length; i < ln; i++) {\n      subkey = subkeys[i];\n      // If the subkey ends in \"]\", remove the ending\n      if (subkey.slice(-1) === \"]\") {\n        subkey = subkey.slice(0, -1);\n      }\n      if (i === ln - 1) {\n        current[subkey] = value;\n        //if value is undefined, delete the property\n        if (value === void 0)\n          delete current[subkey];\n      } else {\n        if (current[subkey] === void 0) {\n          //see if the next piece is a number\n          nextPiece = subkeys[i + 1];\n          nextPiece = parseInt(nextPiece, 10);\n          current[subkey] = isNaN(nextPiece) ? {} : [];\n        }\n        current = current[subkey];\n        if (!isArray(current) && !isBasicObject(current) && i < ln - 1) {\n          return;\n        }\n      }\n    }\n  };\n\n  self.removeValueForPosition = function(position) {\n//    var subkey, subkeys = position.split(\"[\"), current = self._obj;\n//    for (var i = 0, ln = subkeys.length; i < ln; i++) {\n//      subkey = subkeys[i];\n//      // If the subkey ends in \"]\", remove the ending\n//      if (subkey.slice(-1) === \"]\") {\n//        subkey = subkey.slice(0, -1);\n//      }\n//      if (i === ln - 1) {\n//        delete current[subkey];\n//      } else {\n//        current = current[subkey];\n//        if (!isArray(current) && !isBasicObject(current) && i < ln - 1) {\n//          return;\n//        }\n//      }\n//    }\n\n    // Update affected key caches\n    for (var p in self._genericAffectedKeys) {\n      if (self._genericAffectedKeys.hasOwnProperty(p)) {\n        if (position.slice(0, p.length) === p) {\n          delete self._genericAffectedKeys[p];\n          delete self._affectedKeys[p];\n        }\n      }\n    }\n\n    // Rebuild _obj. This is necessary instead of deleting individual\n    // nodes because it's the easier way to make sure ancestor nodes\n    // are deleted as needed, too.\n    self.rebuildObject();\n  };\n\n  // Returns the full array for the requested non-generic key,\n  // if its value is an array\n  self.getArrayInfoForKey = function(key) {\n    key = key + \".$\";\n    var start, firstPositionPiece, v;\n    for (var p in self._genericAffectedKeys) {\n      if (self._genericAffectedKeys.hasOwnProperty(p)) {\n        if (self._genericAffectedKeys[p] === key) {\n          // Get the position string without the final array index\n          start = p.slice(0, p.lastIndexOf(\"[\"));\n          firstPositionPiece = p.slice(0, p.indexOf(\"[\"));\n          v = self.getValueForPosition(start);\n          if (isArray(v)) {\n            return {\n              value: v,\n              operator: (firstPositionPiece.substring(0, 1) === \"$\") ? firstPositionPiece : null\n            };\n          }\n        }\n      }\n    }\n  };\n\n  // Returns the value of the requested non-generic key\n  self.getValueForKey = function(key) {\n    for (var position in self._affectedKeys) {\n      if (self._affectedKeys.hasOwnProperty(position)) {\n        if (self._affectedKeys[position] === key) {\n          // We return the first one we find. While it's\n          // possible that multiple update operators could\n          // affect the same key, mongo generally doesn't\n          // like this, so we'll assume that's not the case.\n          return self.getValueForPosition(position);\n        }\n      }\n    }\n  };\n\n  // Returns the value and operator of the requested non-generic key\n  self.getInfoForKey = function(key) {\n    for (var position in self._affectedKeys) {\n      if (self._affectedKeys.hasOwnProperty(position)) {\n        if (self._affectedKeys[position] === key) {\n          // We return the first one we find. While it's\n          // possible that multiple update operators could\n          // affect the same generic key, especially where\n          // arrays are involved, we'll assume that's not the case.\n          var firstPositionPiece = position.slice(0, position.indexOf(\"[\"));\n          return {\n            value: self.getValueForPosition(position),\n            operator: (firstPositionPiece.substring(0, 1) === \"$\") ? firstPositionPiece : null\n          };\n        }\n      }\n    }\n  };\n\n  // Adds key with value val\n  self.addKey = function(key, val, op) {\n    var position, keyPieces;\n    if (typeof op === \"string\") {\n      position = op + \"[\" + key + \"]\";\n    } else {\n      keyPieces = key.split(\".\");\n      for (var i = 0, ln = keyPieces.length; i < ln; i++) {\n        if (i === 0) {\n          position = keyPieces[i];\n        } else {\n          position += \"[\" + keyPieces[i] + \"]\";\n        }\n      }\n    }\n\n    self.setValueForPosition(position, val);\n    self._affectedKeys[position] = key;\n    self._genericAffectedKeys[position] = makeGeneric(key);\n  };\n\n  // Removes the requested generic key\n  self.removeGenericKey = function(key) {\n    for (var position in self._genericAffectedKeys) {\n      if (self._genericAffectedKeys.hasOwnProperty(position)) {\n        if (self._genericAffectedKeys[position] === key) {\n          self.removeValueForPosition(position);\n        }\n      }\n    }\n  };\n\n  // Removes the requested non-generic key\n  self.removeKey = function(key) {\n    for (var position in self._affectedKeys) {\n      if (self._affectedKeys.hasOwnProperty(position)) {\n        if (self._affectedKeys[position] === key) {\n          self.removeValueForPosition(position);\n        }\n      }\n    }\n  };\n\n  // Removes the requested non-generic keys\n  self.removeKeys = function(keys) {\n    for (var i = 0, ln = keys.length; i < ln; i++) {\n      self.removeKey(keys[i]);\n    }\n  };\n\n  // Passes all affected keys to a test function, which\n  // should return false to remove whatever is affecting that key\n  self.filterGenericKeys = function(test) {\n    var gk, checkedKeys = [];\n    for (var position in self._genericAffectedKeys) {\n      if (self._genericAffectedKeys.hasOwnProperty(position)) {\n        gk = self._genericAffectedKeys[position];\n        if (!_.contains(checkedKeys, gk)) {\n          checkedKeys.push(gk);\n          if (gk && !test(gk)) {\n            self.removeGenericKey(gk);\n          }\n        }\n      }\n    }\n  };\n\n  // Sets the value of the requested non-generic key\n  self.setValueForKey = function(key, val) {\n    for (var position in self._affectedKeys) {\n      if (self._affectedKeys.hasOwnProperty(position)) {\n        if (self._affectedKeys[position] === key) {\n          self.setValueForPosition(position, val);\n        }\n      }\n    }\n  };\n\n  // Sets the value of the requested generic key\n  self.setValueForGenericKey = function(key, val) {\n    for (var position in self._genericAffectedKeys) {\n      if (self._genericAffectedKeys.hasOwnProperty(position)) {\n        if (self._genericAffectedKeys[position] === key) {\n          self.setValueForPosition(position, val);\n        }\n      }\n    }\n  };\n\n  // Gets a normal object based on the MongoObject instance\n  self.getObject = function() {\n    return self._obj;\n  };\n\n  self.rebuildObject = function() {\n    var newObj = {};\n    _.each(self._affectedKeys, function(affectedKey, position) {\n      MongoObject.expandKey(self.getValueForPosition(position), position, newObj);\n    });\n    self._obj = newObj;\n  };\n\n  // Gets a flat object based on the MongoObject instance.\n  // In a flat object, the key is the name of the non-generic affectedKey,\n  // with mongo dot notation if necessary, and the value is the value for\n  // that key.\n  self.getFlatObject = function() {\n    var newObj = {};\n    _.each(self._affectedKeys, function(affectedKey, position) {\n      if (typeof affectedKey === \"string\") {\n        newObj[affectedKey] = self.getValueForPosition(position);\n      }\n    });\n    return newObj;\n  };\n\n  // Returns true if the non-generic key is affected by this object\n  self.affectsKey = function(key) {\n    for (var position in self._affectedKeys) {\n      if (self._affectedKeys.hasOwnProperty(position)) {\n        if (self._affectedKeys[position] === key) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n\n  // Returns true if the generic key is affected by this object\n  self.affectsGenericKey = function(key) {\n    for (var position in self._genericAffectedKeys) {\n      if (self._genericAffectedKeys.hasOwnProperty(position)) {\n        if (self._genericAffectedKeys[position] === key) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n\n  // Like affectsGenericKey, but will return true if a child key is affected\n  self.affectsGenericKeyImplicit = function(key) {\n    for (var position in self._genericAffectedKeys) {\n      if (self._genericAffectedKeys.hasOwnProperty(position)) {\n        var affectedKey = self._genericAffectedKeys[position];\n\n        // If the affected key is the test key\n        if (affectedKey === key) {\n          return true;\n        }\n\n        // If the affected key implies the test key because the affected key\n        // starts with the test key followed by a period\n        if (affectedKey.substring(0, key.length + 1) === key + \".\") {\n          return true;\n        }\n\n        // If the affected key implies the test key because the affected key\n        // starts with the test key and the test key ends with \".$\"\n        var lastTwo = key.slice(-2);\n        if (lastTwo === \".$\" && key.slice(0, -2) === affectedKey) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n};\n\n/** Takes a string representation of an object key and its value\n *  and updates \"obj\" to contain that key with that value.\n *  \n *  Example keys and results if val is 1:\n *    \"a\" -> {a: 1}\n *    \"a[b]\" -> {a: {b: 1}}\n *    \"a[b][0]\" -> {a: {b: [1]}}\n *    \"a[b.0.c]\" -> {a: {'b.0.c': 1}}\n */\n\n/** Takes a string representation of an object key and its value\n *  and updates \"obj\" to contain that key with that value.\n *  \n *  Example keys and results if val is 1:\n *    \"a\" -> {a: 1}\n *    \"a[b]\" -> {a: {b: 1}}\n *    \"a[b][0]\" -> {a: {b: [1]}}\n *    \"a[b.0.c]\" -> {a: {'b.0.c': 1}}\n * \n * @param {any} val\n * @param {String} key\n * @param {Object} obj\n * @returns {undefined}\n */\nMongoObject.expandKey = function(val, key, obj) {\n  var nextPiece, subkey, subkeys = key.split(\"[\"), current = obj;\n  for (var i = 0, ln = subkeys.length; i < ln; i++) {\n    subkey = subkeys[i];\n    if (subkey.slice(-1) === \"]\") {\n      subkey = subkey.slice(0, -1);\n    }\n    if (i === ln - 1) {\n      //last iteration; time to set the value; always overwrite\n      current[subkey] = val;\n      //if val is undefined, delete the property\n      if (val === void 0)\n        delete current[subkey];\n    } else {\n      //see if the next piece is a number\n      nextPiece = subkeys[i + 1];\n      nextPiece = parseInt(nextPiece, 10);\n      if (!current[subkey]) {\n        current[subkey] = isNaN(nextPiece) ? {} : [];\n      }\n    }\n    current = current[subkey];\n  }\n};\n\nvar isArray = Array.isArray || function(obj) {\n  return obj.toString() === '[object Array]';\n};\n\nvar isObject = function(obj) {\n  return obj === Object(obj);\n};\n\n// getPrototypeOf polyfill\nif (typeof Object.getPrototypeOf !== \"function\") {\n  if (typeof \"\".__proto__ === \"object\") {\n    Object.getPrototypeOf = function(object) {\n      return object.__proto__;\n    };\n  } else {\n    Object.getPrototypeOf = function(object) {\n      // May break if the constructor has been tampered with\n      return object.constructor.prototype;\n    };\n  }\n}\n\n/* Tests whether \"obj\" is an Object as opposed to\n * something that inherits from Object\n * \n * @param {any} obj\n * @returns {Boolean}\n */\nvar isBasicObject = function(obj) {\n  return isObject(obj) && Object.getPrototypeOf(obj) === Object.prototype;\n};\n\n/* Takes a specific string that uses mongo-style dot notation\n * and returns a generic string equivalent. Replaces all numeric\n * \"pieces\" with a dollar sign ($).\n * \n * @param {type} name\n * @returns {unresolved}\n */\nvar makeGeneric = function(name) {\n  if (typeof name !== \"string\")\n    return null;\n  return name.replace(/\\.[0-9]+\\./g, '.$.').replace(/\\.[0-9]+/g, '.$');\n};\n\nvar appendAffectedKey = function(affectedKey, key) {\n  if (key === \"$each\") {\n    return affectedKey;\n  } else {\n    return (affectedKey ? affectedKey + \".\" + key : key);\n  }\n};","//URL RegEx from https://gist.github.com/dperini/729294\n//http://mathiasbynens.be/demo/url-regex\n\nif (Meteor.isServer) {\n  S = Npm.require(\"string\");\n}\nif (Meteor.isClient) {\n  S = window.S;\n}\n\n//exported\nSchemaRegEx = {\n  Email: /^([0-9a-zA-Z]([-.\\w]*[0-9a-zA-Z])*@([0-9a-zA-Z][-\\w]*[0-9a-zA-Z]\\.)+[a-zA-Z]{2,9})$/,\n  Url: /^(?:(?:https?|ftp):\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!10(?:\\.\\d{1,3}){3})(?!127(?:\\.\\d{1,3}){3})(?!169\\.254(?:\\.\\d{1,3}){2})(?!192\\.168(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/i\n};\n\nvar defaultMessages = {\n  required: \"[label] is required\",\n  minString: \"[label] must be at least [min] characters\",\n  maxString: \"[label] cannot exceed [max] characters\",\n  minNumber: \"[label] must be at least [min]\",\n  maxNumber: \"[label] cannot exceed [max]\",\n  minDate: \"[label] must be on or before [min]\",\n  maxDate: \"[label] cannot be after [max]\",\n  minCount: \"You must specify at least [minCount] values\",\n  maxCount: \"You cannot specify more than [maxCount] values\",\n  noDecimal: \"[label] must be an integer\",\n  notAllowed: \"[value] is not an allowed value\",\n  expectedString: \"[label] must be a string\",\n  expectedNumber: \"[label] must be a number\",\n  expectedBoolean: \"[label] must be a boolean\",\n  expectedArray: \"[label] must be an array\",\n  expectedObject: \"[label] must be an object\",\n  expectedConstructor: \"[label] must be a [type]\",\n  regEx: \"[label] failed regular expression validation\",\n  keyNotInSchema: \"[label] is not allowed by the schema\"\n};\n\nvar extendedOptions = {};\n\n//exported\nSimpleSchema = function(schema, options) {\n  var self = this, requiredSchemaKeys = [], firstLevelSchemaKeys = [],\n          firstLevelRequiredSchemaKeys = [], valueIsAllowedSchemaKeys = [],\n          firstLevelValueIsAllowedSchemaKeys = [], fieldNameRoot;\n  options = options || {};\n  schema = inflectLabels(addImplicitKeys(expandSchema(schema)));\n  self._schema = schema || {};\n  self._schemaKeys = []; //for speedier checking\n  self._validators = [];\n  //set up default message for each error type\n  self._messages = defaultMessages;\n\n  //set schemaDefinition validator\n  var schemaDefinition = {\n    type: Match.Any,\n    label: Match.Optional(String),\n    optional: Match.Optional(Boolean),\n    min: Match.Optional(Match.OneOf(Number, Date, Function)),\n    max: Match.Optional(Match.OneOf(Number, Date, Function)),\n    minCount: Match.Optional(Number),\n    maxCount: Match.Optional(Number),\n    allowedValues: Match.Optional([Match.Any]),\n    valueIsAllowed: Match.Optional(Function),\n    decimal: Match.Optional(Boolean),\n    regEx: Match.Optional(Match.OneOf(RegExp, [RegExp]))\n  };\n\n  // This way of extending options is deprecated. TODO Remove this eventually\n  if (typeof options.additionalKeyPatterns === \"object\")\n    _.extend(schemaDefinition, options.additionalKeyPatterns);\n\n  // Extend schema options\n  _.extend(schemaDefinition, extendedOptions);\n\n  _.each(schema, function(definition, fieldName) {\n    // Validate the field definition\n    if (!Match.test(definition, schemaDefinition)) {\n      throw new Error('Invalid definition for ' + fieldName + ' field.');\n    }\n\n    fieldNameRoot = fieldName.split(\".\")[0];\n\n    self._schemaKeys.push(fieldName);\n\n    if (!_.contains(firstLevelSchemaKeys, fieldNameRoot)) {\n      firstLevelSchemaKeys.push(fieldNameRoot);\n      if (!definition.optional) {\n        firstLevelRequiredSchemaKeys.push(fieldNameRoot);\n      }\n      \n      if (definition.valueIsAllowed) {\n        firstLevelValueIsAllowedSchemaKeys.push(fieldNameRoot);\n      }\n    }\n\n    if (!definition.optional) {\n      requiredSchemaKeys.push(fieldName);\n    }\n    \n    if (definition.valueIsAllowed) {\n      valueIsAllowedSchemaKeys.push(fieldName);\n    }\n  });\n\n  // Cache these lists\n  self._requiredSchemaKeys = requiredSchemaKeys;\n  self._firstLevelSchemaKeys = firstLevelSchemaKeys;\n  self._firstLevelRequiredSchemaKeys = firstLevelRequiredSchemaKeys;\n  self._requiredObjectKeys = getObjectKeys(schema, requiredSchemaKeys);\n  self._valueIsAllowedSchemaKeys = valueIsAllowedSchemaKeys;\n  self._firstLevelValueIsAllowedSchemaKeys = firstLevelValueIsAllowedSchemaKeys;\n  self._valueIsAllowedObjectKeys = getObjectKeys(schema, valueIsAllowedSchemaKeys);\n\n  // We will store named validation contexts here\n  self._validationContexts = {};\n};\n\n// This allows other packages to extend the schema definition options that\n// are supported.\nSimpleSchema.extendOptions = function(options) {\n  _.extend(extendedOptions, options);\n};\n\n// Inherit from Match.Where\n// This allow SimpleSchema instance to be recognized as a Match.Where instance as well\n// as a SimpleSchema instance\nSimpleSchema.prototype = new Match.Where();\n\n// If an object is an instance of Match.Where, Meteor built-in check API will look at\n// the function named `condition` and will pass it the document to validate\nSimpleSchema.prototype.condition = function(obj) {\n  var self = this;\n  \n  //determine whether obj is a modifier\n  var isModifier, isNotModifier;\n  _.each(obj, function(val, key) {\n    if (key.substring(0, 1) === \"$\") {\n      isModifier = true;\n    } else {\n      isNotModifier = true;\n  }\n  });\n\n  if (isModifier && isNotModifier)\n    throw new Match.Error(\"Object cannot contain modifier operators alongside other keys\");\n\n  if (!self.newContext().validate(obj, {modifier: isModifier, filter: false, autoConvert: false}))\n    throw new Match.Error(\"One or more properties do not match the schema.\");\n  \n  return true;\n};\n\nSimpleSchema.prototype.namedContext = function(name) {\n  var self = this;\n  if (typeof name !== \"string\") {\n    name = \"default\";\n  }\n  self._validationContexts[name] = self._validationContexts[name] || new SimpleSchemaValidationContext(self);\n  return self._validationContexts[name];\n};\n\nSimpleSchema.prototype.validator = function(func) {\n  this._validators.push(func);\n};\n\n// Filter and automatically type convert\nSimpleSchema.prototype.clean = function(doc, options) {\n  var self = this;\n\n  // By default, doc will be filtered and autoconverted\n  options = _.extend({\n    filter: true,\n    autoConvert: true\n  }, options || {});\n\n  // Convert $pushAll (deprecated) to $push with $each\n  if (\"$pushAll\" in doc) {\n    doc.$push = doc.$push || {};\n    for (var field in doc.$pushAll) {\n      doc.$push[field] = doc.$push[field] || {};\n      doc.$push[field].$each = doc.$push[field].$each || [];\n      for (var i = 0, ln = doc.$pushAll[field].length; i < ln; i++) {\n        doc.$push[field].$each.push(doc.$pushAll[field][i]);\n      }\n      delete doc.$pushAll;\n    }\n  }\n\n  var mDoc = new MongoObject(doc);\n\n  // Filter out anything that would affect keys not defined\n  // or implied by the schema\n  options.filter && mDoc.filterGenericKeys(function(genericKey) {\n    return self.allowsKey(genericKey);\n  });\n\n  // Autoconvert values if requested and if possible\n  options.autoConvert && mDoc.forEachNode(function(val, position, affectedKey, affectedKeyGeneric) {\n    if (affectedKeyGeneric) {\n      var def = self._schema[affectedKeyGeneric];\n      def && this.updateValue(typeconvert(val, def.type));\n    }\n  });\n  \n  return mDoc.getObject();\n};\n\n// Returns the entire schema object or just the definition for one key\n// in the schema.\nSimpleSchema.prototype.schema = function(key) {\n  var self = this;\n  if (key) {\n    return self._schema[key];\n  } else {\n    return self._schema;\n  }\n};\n\nSimpleSchema.prototype.messages = function(messages) {\n  this._messages = defaultMessages; //make sure we're always extending the defaults, even if called more than once\n  _.extend(this._messages, messages);\n};\n\n// Use to dynamically change the schema labels.\nSimpleSchema.prototype.labels = function(labels) {\n  var self = this;\n  _.each(labels, function(label, fieldName) {\n    if (typeof label !== \"string\")\n      return;\n\n    if (!(fieldName in self._schema))\n      return;\n\n    self._schema[fieldName][\"label\"] = label;\n  });\n};\n\n// Returns a string message for the given error type and key. Uses the\n// def and value arguments to fill in placeholders in the error messages.\nSimpleSchema.prototype.messageForError = function(type, key, def, value) {\n  var self = this, typePlusKey = type + \" \" + key, genType, genTypePlusKey, firstTypePeriod = type.indexOf(\".\");\n  if (firstTypePeriod !== -1) {\n    genType = type.substring(0, firstTypePeriod);\n    genTypePlusKey = genType + \" \" + key;\n  }\n  var message = self._messages[typePlusKey] || self._messages[type];\n  if (!message && genType) {\n    message = self._messages[genTypePlusKey] || self._messages[genType];\n  }\n  if (!message)\n    return \"Unknown validation error\";\n  def = def || self._schema[key] || {};\n  message = message.replace(\"[label]\", def.label || key);\n  if (typeof def.minCount !== \"undefined\") {\n    message = message.replace(\"[minCount]\", def.minCount);\n  }\n  if (typeof def.maxCount !== \"undefined\") {\n    message = message.replace(\"[maxCount]\", def.maxCount);\n  }\n  if (value !== void 0 && value !== null) {\n    message = message.replace(\"[value]\", value.toString());\n  }\n  var min = def.min;\n  var max = def.max;\n  if (typeof min === \"function\") {\n    min = min();\n  }\n  if (typeof max === \"function\") {\n    max = max();\n  }\n  if (def.type === Date || def.type === [Date]) {\n    if (typeof min !== \"undefined\") {\n      message = message.replace(\"[min]\", dateToDateString(min));\n    }\n    if (typeof max !== \"undefined\") {\n      message = message.replace(\"[max]\", dateToDateString(max));\n    }\n  } else {\n    if (typeof min !== \"undefined\") {\n      message = message.replace(\"[min]\", min);\n    }\n    if (typeof max !== \"undefined\") {\n      message = message.replace(\"[max]\", max);\n    }\n  }\n  if (def.type instanceof Function) {\n    message = message.replace(\"[type]\", def.type.name);\n  }\n  return message;\n};\n\n// Returns true if key is explicitly allowed by the schema or implied\n// by other explicitly allowed keys.\n// The key string should have $ in place of any numeric array positions.\nSimpleSchema.prototype.allowsKey = function(key) {\n  var self = this, schemaKeys = self._schemaKeys;\n\n  // Begin by assuming it's not allowed.\n  var allowed = false;\n\n  // Loop through all keys in the schema\n  for (var i = 0, ln = schemaKeys.length, schemaKey; i < ln; i++) {\n    schemaKey = schemaKeys[i];\n\n    // If the schema key is the test key, it's allowed.\n    if (schemaKey === key) {\n      allowed = true;\n      break;\n    }\n\n    // If the schema key implies the test key because the schema key\n    // starts with the test key followed by a period, it's allowed.\n    if (schemaKey.substring(0, key.length + 1) === key + \".\") {\n      allowed = true;\n      break;\n    }\n\n    // If the schema key implies the test key because the schema key\n    // starts with the test key and the test key ends with \".$\", it's allowed.\n    var lastTwo = key.slice(-2);\n    if (lastTwo === \".$\" && key.slice(0, -2) === schemaKey) {\n      allowed = true;\n      break;\n    }\n  }\n\n  return allowed;\n};\n\nSimpleSchema.prototype.newContext = function() {\n  return new SimpleSchemaValidationContext(this);\n};\n\nSimpleSchema.prototype.requiredObjectKeys = function(keyPrefix) {\n  var self = this;\n  if (!keyPrefix) {\n    return self._firstLevelRequiredSchemaKeys;\n  }\n  return self._requiredObjectKeys[keyPrefix + \".\"] || [];\n};\n\nSimpleSchema.prototype.requiredSchemaKeys = function() {\n  return this._requiredSchemaKeys;\n};\n\nSimpleSchema.prototype.firstLevelSchemaKeys = function() {\n  return this._firstLevelSchemaKeys;\n};\n\nSimpleSchema.prototype.valueIsAllowedObjectKeys = function(keyPrefix) {\n  var self = this;\n  if (!keyPrefix) {\n    return self._firstLevelValueIsAllowedSchemaKeys;\n  }\n  return self._valueIsAllowedObjectKeys[keyPrefix + \".\"] || [];\n};\n\nSimpleSchema.prototype.valueIsAllowedSchemaKeys = function() {\n  return this._valueIsAllowedSchemaKeys;\n};\n\n//called by clean()\nvar typeconvert = function(value, type) {\n  if (type === String) {\n    if (typeof value !== \"undefined\" && value !== null && typeof value !== \"string\") {\n      return value.toString();\n    }\n    return value;\n  }\n  if (type === Number) {\n    if (typeof value === \"string\") {\n      //try to convert numeric strings to numbers\n      var floatVal = parseFloat(value);\n      if (!isNaN(floatVal)) {\n        return floatVal;\n      } else {\n        return value; //leave string; will fail validation\n      }\n    }\n    return value;\n  }\n  return value;\n};\n\n//tests whether it's an Object as opposed to something that inherits from Object\nvar isBasicObject = function(obj) {\n  return _.isObject(obj) && Object.getPrototypeOf(obj) === Object.prototype;\n};\n\nlooksLikeModifier = function(obj) {\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key) && key.substring(0, 1) === \"$\") {\n      return true;\n    }\n  }\n  return false;\n};\n\nvar dateToDateString = function(date) {\n  var m = (date.getUTCMonth() + 1);\n  if (m < 10) {\n    m = \"0\" + m;\n  }\n  var d = date.getUTCDate();\n  if (d < 10) {\n    d = \"0\" + d;\n  }\n  return date.getUTCFullYear() + '-' + m + '-' + d;\n};\n\nvar expandSchema = function(schema) {\n  // If schema is an array of schemas, merge them first\n  if (_.isArray(schema)) {\n    var mergedSchema = {};\n    _.each(schema, function(ss) {\n      ss = Match.test(ss, SimpleSchema) ? ss._schema : ss;\n      isBasicObject(ss) && _.extend(mergedSchema, ss);\n    });\n    schema = mergedSchema;\n  }\n\n  // Now flatten schema by inserting nested definitions\n  _.each(schema, function(val, key) {\n    var dot, type;\n    if (Match.test(val.type, SimpleSchema)) {\n      dot = '.';\n      type = val.type;\n      val.type = Object;\n    } else if (Match.test(val.type, [SimpleSchema])) {\n      dot = '.$.';\n      type = val.type[0];\n      val.type = [Object];\n    } else {\n      return;\n    }\n    //add child schema definitions to parent schema\n    _.each(type._schema, function(subVal, subKey) {\n      var newKey = key + dot + subKey;\n      if (!(newKey in schema))\n        schema[newKey] = subVal;\n    });\n  });\n  return schema;\n};\n\n/**\n * Adds implied keys.\n * * If schema contains a key like \"foo.$.bar\" but not \"foo\", adds \"foo\".\n * * If schema contains a key like \"foo\" with an array type, adds \"foo.$\".\n * @param {Object} schema\n * @returns {Object} modified schema\n */\nvar addImplicitKeys = function(schema) {\n  var arrayKeysToAdd = [], objectKeysToAdd = [], newKey, key, nextThree;\n\n  // Pass 1 (objects)\n  _.each(schema, function(def, existingKey) {\n    var pos = existingKey.indexOf(\".\");\n\n    while (pos !== -1) {\n      newKey = existingKey.substring(0, pos);\n      nextThree = existingKey.substring(pos, pos + 3);\n      if (newKey.substring(newKey.length - 2) !== \".$\") {\n        if (nextThree === \".$.\") {\n          arrayKeysToAdd.push(newKey);\n        } else {\n          objectKeysToAdd.push(newKey);\n        }\n      }\n      pos = existingKey.indexOf(\".\", pos + 3);\n    }\n  });\n\n  for (var i = 0, ln = arrayKeysToAdd.length; i < ln; i++) {\n    key = arrayKeysToAdd[i];\n    if (!(key in schema)) {\n      schema[key] = {type: [Object], optional: true};\n    }\n  }\n\n  for (var i = 0, ln = objectKeysToAdd.length; i < ln; i++) {\n    key = objectKeysToAdd[i];\n    if (!(key in schema)) {\n      schema[key] = {type: Object, optional: true};\n    }\n  }\n\n  // Pass 2 (arrays)\n  _.each(schema, function(def, existingKey) {\n    if (_.isArray(def.type)) {\n      // Copy some options to array-item definition\n      var itemKey = existingKey + \".$\";\n      if (!(itemKey in schema)) {\n        schema[itemKey] = {};\n      }\n      //var itemDef = schema[itemKey];\n      schema[itemKey].type = def.type[0];\n      if (def.label) {\n        schema[itemKey].label = def.label;\n      }\n      schema[itemKey].optional = true;\n      if (typeof def.min !== \"undefined\") {\n        schema[itemKey].min = def.min;\n      }\n      if (typeof def.max !== \"undefined\") {\n        schema[itemKey].max = def.max;\n      }\n      if (typeof def.allowedValues !== \"undefined\") {\n        schema[itemKey].allowedValues = def.allowedValues;\n      }\n      if (typeof def.valueIsAllowed !== \"undefined\") {\n        schema[itemKey].valueIsAllowed = def.valueIsAllowed;\n      }\n      if (typeof def.decimal !== \"undefined\") {\n        schema[itemKey].decimal = def.decimal;\n      }\n      if (typeof def.regEx !== \"undefined\") {\n        schema[itemKey].regEx = def.regEx;\n      }\n      // Remove copied options and adjust type\n      def.type = Array;\n      _.each(['min', 'max', 'allowedValues', 'valueIsAllowed', 'decimal', 'regEx'], function(k) {\n        deleteIfPresent(def, k);\n      });\n    }\n  });\n\n  for (var i = 0, ln = arrayKeysToAdd.length; i < ln; i++) {\n    key = arrayKeysToAdd[i];\n    if (!(key in schema)) {\n      schema[key] = {type: [Object], optional: true};\n    }\n  }\n\n  for (var i = 0, ln = objectKeysToAdd.length; i < ln; i++) {\n    key = objectKeysToAdd[i];\n    if (!(key in schema)) {\n      schema[key] = {type: Object, optional: true};\n    }\n  }\n\n  return schema;\n};\n\n// Returns an object relating the keys in the list\n// to their parent object.\nvar getObjectKeys = function(schema, schemaKeyList) {\n  var keyPrefix, remainingText, rKeys = {}, loopArray;\n  _.each(schema, function(definition, fieldName) {\n    if (definition.type === Object) {\n      //object\n      keyPrefix = fieldName + \".\";\n    } else {\n      return;\n    }\n\n    loopArray = [];\n    _.each(schemaKeyList, function(fieldName2) {\n      if (S(fieldName2).startsWith(keyPrefix)) {\n        remainingText = fieldName2.substring(keyPrefix.length);\n        if (remainingText.indexOf(\".\") === -1) {\n          loopArray.push(remainingText);\n        }\n      }\n    });\n    rKeys[keyPrefix] = loopArray;\n  });\n  return rKeys;\n};\n\n//label inflection\nvar inflectLabels = function(schema) {\n  if (!_.isObject(schema))\n    return schema;\n\n  var editedSchema = {};\n  _.each(schema, function(definition, fieldName) {\n    if (typeof definition.label === \"string\") {\n      editedSchema[fieldName] = definition;\n      return;\n    }\n\n    var label = fieldName, lastPeriod = label.lastIndexOf(\".\");\n    if (lastPeriod !== -1) {\n      label = label.substring(lastPeriod + 1);\n      if (label === \"$\") {\n        var pcs = fieldName.split(\".\");\n        label = pcs[pcs.length - 2];\n      }\n    }\n    definition.label = S(label).humanize().s;\n    editedSchema[fieldName] = definition;\n  });\n\n  return editedSchema;\n};\n\nvar deleteIfPresent = function (obj, key) {\n  if (key in obj) {\n    delete obj[key];\n  }\n};","/*\n * PUBLIC API\n */\n\nSimpleSchemaValidationContext = function(ss) {\n  var self = this;\n  self._simpleSchema = ss;\n  self._schema = ss.schema();\n  self._schemaKeys = _.keys(self._schema);\n  self._invalidKeys = [];\n  //set up validation dependencies\n  self._deps = {};\n  self._depsAny = new Deps.Dependency;\n  _.each(self._schemaKeys, function(name) {\n    self._deps[name] = new Deps.Dependency;\n  });\n};\n\n//validates the object against the simple schema and sets a reactive array of error objects\nSimpleSchemaValidationContext.prototype.validate = function(doc, options) {\n  var self = this;\n  options = _.extend({\n    modifier: false,\n    upsert: false\n  }, options || {});\n\n  //clean doc\n  doc = self._simpleSchema.clean(doc, options);\n\n  var invalidKeys = doValidation(doc, options.modifier, options.upsert, null, self._simpleSchema);\n\n  //now update self._invalidKeys and dependencies\n\n  //note any currently invalid keys so that we can mark them as changed\n  //due to new validation (they may be valid now, or invalid in a different way)\n  var removedKeys = _.pluck(self._invalidKeys, \"name\");\n\n  //update\n  self._invalidKeys = invalidKeys;\n\n  //add newly invalid keys to changedKeys\n  var addedKeys = _.pluck(self._invalidKeys, \"name\");\n\n  //mark all changed keys as changed\n  var changedKeys = _.union(addedKeys, removedKeys);\n  _.each(changedKeys, function(name) {\n    var genericName = makeGeneric(name);\n    if (genericName in self._deps) {\n      self._deps[genericName].changed();\n    }\n  });\n  if (changedKeys.length) {\n    self._depsAny.changed();\n  }\n\n  // Return true if it was valid; otherwise, return false\n  return self._invalidKeys.length === 0;\n};\n\n//validates doc against self._schema for one key and sets a reactive array of error objects\nSimpleSchemaValidationContext.prototype.validateOne = function(doc, keyName, options) {\n  var self = this;\n  options = _.extend({\n    modifier: false\n  }, options || {});\n\n  //clean doc\n  doc = self._simpleSchema.clean(doc, options);\n\n  var invalidKeys = doValidation(doc, options.modifier, options.upsert, keyName, self._simpleSchema);\n\n  //now update self._invalidKeys and dependencies\n\n  //remove objects from self._invalidKeys where name = keyName\n  var newInvalidKeys = [];\n  for (var i = 0, ln = self._invalidKeys.length, k; i < ln; i++) {\n    k = self._invalidKeys[i];\n    if (k.name !== keyName) {\n      newInvalidKeys.push(k);\n    }\n  }\n  self._invalidKeys = newInvalidKeys;\n\n  //merge invalidKeys into self._invalidKeys\n  for (var i = 0, ln = invalidKeys.length, k; i < ln; i++) {\n    k = invalidKeys[i];\n    self._invalidKeys.push(k);\n  }\n\n  //mark key as changed due to new validation (they may be valid now, or invalid in a different way)\n  var genericName = makeGeneric(keyName);\n  if (genericName in self._deps) {\n    self._deps[genericName].changed();\n  }\n  self._depsAny.changed();\n\n  // Return true if it was valid; otherwise, return false\n  return !self._keyIsInvalid(keyName);\n};\n\n//reset the invalidKeys array\nSimpleSchemaValidationContext.prototype.resetValidation = function() {\n  var self = this;\n  var removedKeys = _.pluck(self._invalidKeys, \"name\");\n  self._invalidKeys = [];\n  _.each(removedKeys, function(name) {\n    var genericName = makeGeneric(name);\n    if (genericName in self._deps) {\n      self._deps[genericName].changed();\n    }\n  });\n};\n\nSimpleSchemaValidationContext.prototype.isValid = function() {\n  var self = this;\n  self._depsAny.depend();\n  return !self._invalidKeys.length;\n};\n\nSimpleSchemaValidationContext.prototype.invalidKeys = function() {\n  var self = this;\n  self._depsAny.depend();\n  return self._invalidKeys;\n};\n\nSimpleSchemaValidationContext.prototype._keyIsInvalid = function(name, genericName) {\n  var self = this;\n  genericName = genericName || makeGeneric(name);\n  var specificIsInvalid = !!_.findWhere(self._invalidKeys, {name: name});\n  var genericIsInvalid = (genericName !== name) ? (!!_.findWhere(self._invalidKeys, {name: genericName})) : false;\n  return specificIsInvalid || genericIsInvalid;\n};\n\nSimpleSchemaValidationContext.prototype.keyIsInvalid = function(name) {\n  var self = this, genericName = makeGeneric(name);\n  self._deps[genericName].depend();\n  return self._keyIsInvalid(name, genericName);\n};\n\nSimpleSchemaValidationContext.prototype.keyErrorMessage = function(name) {\n  var self = this, genericName = makeGeneric(name);\n  self._deps[genericName].depend();\n  var errorObj = _.findWhere(self._invalidKeys, {name: name});\n  if (!errorObj) {\n    errorObj = _.findWhere(self._invalidKeys, {name: genericName});\n  }\n  return errorObj ? errorObj.message : \"\";\n};\n\n/*\n * PRIVATE\n */\n\nvar doValidation = function(obj, isModifier, isUpsert, keyToValidate, ss) {\n  \n  // First do some basic checks of the object, and throw errors if necessary\n  if (!_.isObject(obj)) {\n    throw new Error(\"The first argument of validate() or validateOne() must be an object\");\n  }\n  \n  if (isModifier) {\n    if (_.isEmpty(obj)) {\n      throw new Error(\"When the modifier option is true, validation object must have at least one operator\");\n    } else {\n      var allKeysAreOperators = _.every(obj, function (v, k) {\n        return (k.substring(0, 1) === \"$\");\n      });\n      if (!allKeysAreOperators) {\n        throw new Error(\"When the modifier option is true, all validation object keys must be operators\");\n      }\n    }\n  } else if (looksLikeModifier(obj)) {\n    throw new Error(\"When the validation object contains mongo operators, you must set the modifier option to true\");\n  }\n\n  // If this is an upsert, add all the $setOnInsert keys to $set;\n  // since we don't know whether it will be an insert or update, we'll\n  // validate upserts as if they will be an insert.\n  // TODO It would be more secure to validate twice, once as\n  // an update and once as an insert, because $set validation does not\n  // consider missing required keys to be an issue.\n  if (\"$setOnInsert\" in obj) {\n    if (isUpsert) {\n      obj.$set = obj.$set || {};\n      obj.$set = _.extend(obj.$set, obj.$setOnInsert);\n    }\n    delete obj.$setOnInsert;\n  }\n  \n  var invalidKeys = [];\n\n  // Validation function called for each affected key\n  function validate(val, affectedKey, affectedKeyGeneric, def, op) {\n\n    // Get the schema for this key, marking invalid if there isn't one.\n    if (!def) {\n      invalidKeys.push(errorObject(\"keyNotInSchema\", affectedKey, val, def, ss));\n      return;\n    }\n\n    // Check for missing required values. The general logic is this:\n    // * If there's no operator, or if the operator is $set and it's an upsert,\n    //   val must not be undefined, null, or an empty string.\n    // * If there is an operator other than $unset or $rename, val must\n    //   not be null or an empty string, but undefined is OK.\n    // * If the operator is $unset or $rename, it's invalid.\n    if (!def.optional) {\n      if (op === \"$unset\" || op === \"$rename\" || isBlankNullOrUndefined(val)) {\n        invalidKeys.push(errorObject(\"required\", affectedKey, null, def, ss));\n        return;\n      }\n    }\n\n    // For $rename, make sure that the new name is allowed by the schema\n    if (op === \"$rename\" && typeof val === \"string\" && !ss.allowsKey(val)) {\n      invalidKeys.push(errorObject(\"keyNotInSchema\", val, null, null, ss));\n      return;\n    }\n\n    // Value checks are not necessary for null or undefined values,\n    // or for certain operators.\n    if (!_.contains([\"$unset\", \"$rename\", \"$pull\", \"$pullAll\", \"$pop\"], op)) {\n      \n      if (isSet(val)) {\n\n        // Check that value is of the correct type\n        var typeError = doTypeChecks(def, val, op);\n        if (typeError) {\n          invalidKeys.push(errorObject(typeError, affectedKey, val, def, ss));\n          return;\n        }\n\n        // Check value against allowedValues array\n        if (def.allowedValues && !_.contains(def.allowedValues, val)) {\n          invalidKeys.push(errorObject(\"notAllowed\", affectedKey, val, def, ss));\n          return;\n        }\n      \n      }\n\n      // Check value using valusIsAllowed function\n      if (def.valueIsAllowed && !def.valueIsAllowed(val, obj, op)) {\n        invalidKeys.push(errorObject(\"notAllowed\", affectedKey, val, def, ss));\n        return;\n      }\n\n    }\n\n    // Perform custom validation\n    _.every(ss._validators, function(validator) {\n      var errorType = validator(affectedKeyGeneric, val, def, op);\n      if (typeof errorType === \"string\") {\n        invalidKeys.push(errorObject(errorType, affectedKey, val, def, ss));\n        return false;\n      }\n      return true;\n    });\n  }\n\n  // The recursive function\n  function checkObj(val, affectedKey, operator, adjusted) {\n    var affectedKeyGeneric, def;\n    \n    // Adjust for first-level modifier operators\n    if (!operator && affectedKey && affectedKey.substring(0, 1) === \"$\") {\n      operator = affectedKey;\n      affectedKey = null;\n    }\n\n    if (affectedKey) {\n\n      // Adjust for $push and $addToSet\n      if (! adjusted && (operator === \"$push\" || operator === \"$addToSet\")) {\n        // Adjust for $each\n        // We can simply jump forward and pretend like the $each array\n        // is the array for the field. This has the added benefit of\n        // skipping past any $slice, which we also don't care about.\n        if (isBasicObject(val) && \"$each\" in val) {\n          val = val.$each;\n        } else {\n          affectedKey = affectedKey + \".0\";\n        }\n        adjusted = true;\n      }\n\n      // Make a generic version of the affected key, and use that\n      // to get the schema for this key.\n      affectedKeyGeneric = makeGeneric(affectedKey);\n      def = ss.schema(affectedKeyGeneric);\n\n      // Perform validation for this key\n      if (!keyToValidate || keyToValidate === affectedKey || keyToValidate === affectedKeyGeneric) {\n        validate(val, affectedKey, affectedKeyGeneric, def, operator);\n      }\n    }\n\n    // Temporarily convert missing objects to empty objects\n    // so that the looping code will be called and required\n    // descendent keys can be validated.\n    if (!val && (!def || def.type === Object)) {\n      val = {};\n    }\n\n    // Loop through arrays\n    if (_.isArray(val)) {\n      _.each(val, function(v, i) {\n        checkObj(v, affectedKey + '.' + i, operator, adjusted);\n      });\n    }\n    \n    // Loop through object keys\n    else if (isBasicObject(val)) {\n      \n      // Get list of present keys\n      var presentKeys = _.keys(val);\n      \n      // For required checks, we want to also loop through all keys expected\n      // based on the schema, in case any are missing.\n      var requiredKeys, valueIsAllowedKeys;\n      if (!isModifier || (isUpsert && operator === \"$set\") || (affectedKeyGeneric && affectedKeyGeneric.slice(-2) === \".$\")) {\n        requiredKeys = ss.requiredObjectKeys(affectedKeyGeneric);\n        \n        // Filter out required keys that are ancestors\n        // of those in $set\n        requiredKeys = _.filter(requiredKeys, function (k) {\n          return !_.some(presentKeys, function (pk) {\n            return (pk.slice(0, k.length + 1) === k + \".\");\n          });\n        });\n      }\n      \n      if (!isModifier || (operator === \"$set\") || (affectedKeyGeneric && affectedKeyGeneric.slice(-2) === \".$\")) {\n      \n        // We want to be sure to call any present valueIsAllowed functions\n        // even if the value isn't set, so they can be used for custom\n        // required errors, such as basing it on another field's value.\n        valueIsAllowedKeys = ss.valueIsAllowedObjectKeys(affectedKeyGeneric);\n\n      }\n      \n      // Merge the lists\n      var keysToCheck = _.union(presentKeys, requiredKeys || [], valueIsAllowedKeys || []);\n      \n      // Check all keys in the merged list\n      _.each(keysToCheck, function(key) {\n        if (shouldCheck(key)) {\n          checkObj(val[key], appendAffectedKey(affectedKey, key), operator, adjusted);\n        }\n      });\n    }\n    \n  }\n  \n  // Kick off the validation\n  checkObj(obj);\n\n  // Make sure there is only one error per fieldName\n  var addedFieldNames = [];\n  invalidKeys = _.filter(invalidKeys, function(errObj) {\n    if (!_.contains(addedFieldNames, errObj.name)) {\n      addedFieldNames.push(errObj.name);\n      return true;\n    }\n    return false;\n  });\n\n  return invalidKeys;\n};\n\nvar doTypeChecks = function(def, keyValue, op) {\n  var expectedType = def.type;\n\n  // If min/max are functions, call them\n  var min = def.min;\n  var max = def.max;\n  if (typeof min === \"function\") {\n    min = min();\n  }\n  if (typeof max === \"function\") {\n    max = max();\n  }\n\n  // String checks\n  if (expectedType === String) {\n    if (typeof keyValue !== \"string\") {\n      return \"expectedString\";\n    } else if (max !== null && max < keyValue.length) {\n      return \"maxString\";\n    } else if (min !== null && min > keyValue.length) {\n      return \"minString\";\n    } else if (def.regEx instanceof RegExp && !def.regEx.test(keyValue)) {\n      return \"regEx\";\n    } else if (_.isArray(def.regEx)) {\n      var regExError;\n      _.every(def.regEx, function(re, i) {\n        if (!re.test(keyValue)) {\n          regExError = \"regEx.\" + i;\n          return false;\n        }\n        return true;\n      });\n      if (regExError)\n        return regExError;\n    }\n  }\n\n  // Number checks\n  else if (expectedType === Number) {\n    if (typeof keyValue !== \"number\") {\n      return \"expectedNumber\";\n    } else if (op !== \"$inc\" && max !== null && max < keyValue) {\n      return \"maxNumber\";\n    } else if (op !== \"$inc\" && min !== null && min > keyValue) {\n      return \"minNumber\";\n    } else if (!def.decimal && keyValue.toString().indexOf(\".\") > -1) {\n      return \"noDecimal\";\n    }\n  }\n\n  // Boolean checks\n  else if (expectedType === Boolean) {\n    if (typeof keyValue !== \"boolean\") {\n      return \"expectedBoolean\";\n    }\n  }\n\n  // Object checks\n  else if (expectedType === Object) {\n    if (!isBasicObject(keyValue)) {\n      return \"expectedObject\";\n    }\n  }\n\n  // Array checks\n  else if (expectedType === Array) {\n    if (!_.isArray(keyValue)) {\n      return \"expectedArray\";\n    } else if (def.minCount !== null && keyValue.length < def.minCount) {\n      return \"minCount\";\n    } else if (def.maxCount !== null && keyValue.length > def.maxCount) {\n      return \"maxCount\";\n    }\n  }\n\n  // Constructor function checks\n  else if (expectedType instanceof Function || safariBugFix(expectedType)) {\n\n    // Generic constructor checks\n    if (!(keyValue instanceof expectedType)) {\n      return \"expectedConstructor\";\n    }\n\n    // Date checks\n    else if (expectedType === Date) {\n      if (_.isDate(min) && min.getTime() > keyValue.getTime()) {\n        return \"minDate\";\n      } else if (_.isDate(max) && max.getTime() < keyValue.getTime()) {\n        return \"maxDate\";\n      }\n    }\n  }\n\n};\n\n/*\n * HELPERS\n */\n\nvar appendAffectedKey = function(affectedKey, key) {\n  if (key === \"$each\") {\n    return affectedKey;\n  } else {\n    return (affectedKey ? affectedKey + \".\" + key : key);\n  }\n};\n\nvar shouldCheck = function(key) {\n  if (key === \"$pushAll\") {\n    throw new Error(\"$pushAll is not supported; use $push + $each\");\n  }\n  return !_.contains([\"$pull\", \"$pullAll\", \"$pop\", \"$slice\"], key);\n};\n\nvar isBlank = function(str) {\n  if (typeof str !== \"string\") {\n    return false;\n  }\n  return (/^\\s*$/).test(str);\n};\n\nvar isBlankNullOrUndefined = function(str) {\n  return (str === void 0 || str === null || isBlank(str));\n};\n\nvar errorObject = function(errorType, keyName, keyValue, def, ss) {\n  return {name: keyName, type: errorType, message: ss.messageForError(errorType, keyName, def, keyValue)};\n};\n\n// Tests whether it's an Object as opposed to something that inherits from Object\nvar isBasicObject = function(obj) {\n  return _.isObject(obj) && Object.getPrototypeOf(obj) === Object.prototype;\n};\n\n// The latest Safari returns false for Uint8Array, etc. instanceof Function\n// unlike other browsers.\nvar safariBugFix = function(type) {\n  return (typeof Uint8Array !== \"undefined\" && type === Uint8Array)\n          || (typeof Uint16Array !== \"undefined\" && type === Uint16Array)\n          || (typeof Uint32Array !== \"undefined\" && type === Uint32Array)\n          || (typeof Uint8ClampedArray !== \"undefined\" && type === Uint8ClampedArray);\n};\n\nvar isSet = function(val) {\n  return val !== void 0 && val !== null;\n};\n\nvar makeGeneric = function(name) {\n  if (typeof name !== \"string\")\n    return null;\n\n  return name.replace(/\\.[0-9]+\\./g, '.$.').replace(/\\.[0-9]+/g, '.$');\n};\n"]}