{"version":3,"file":"/packages/iron-router.js","sources":["iron-router/lib/utils.js","iron-router/lib/route.js","iron-router/lib/route_controller.js","iron-router/lib/router.js","iron-router/lib/server/route_controller.js","iron-router/lib/server/router.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA,G;AACA,sD;AACA,G;;AAEA,W;;AAEA,G;AACA,mD;AACA,G;;AAEA,4B;AACA,oC;AACA,kB;AACA,yC;AACA,kB;AACA,M;AACA,gB;AACA,E;;AAEA,G;AACA,8E;AACA,+E;AACA,e;AACA,E;AACA,Y;AACA,uD;AACA,+D;AACA,E;AACA,qC;AACA,G;;AAEA,6C;AACA,6B;AACA,W;AACA,U;;AAEA,gC;AACA,kC;AACA,iB;AACA,4C;AACA,0B;AACA,e;AACA,yB;AACA,K;AACA,U;AACA,sB;AACA,G;;AAEA,uD;AACA,a;AACA,E;;AAEA,4C;AACA,+B;AACA,6B;AACA,E;;AAEA,G;AACA,uE;AACA,4E;AACA,+E;AACA,yD;AACA,G;;AAEA,2C;AACA,kD;AACA,4E;AACA,G;AACA,mD;AACA,6E;;AAEA,2B;AACA,0C;AACA,+B;AACA,G;;AAEA,oB;AACA,6B;AACA,G;;AAEA,oC;AACA,+B;AACA,qC;AACA,e;AACA,E;;AAEA,gC;AACA,W;AACA,c;AACA,kD;AACA,iB;AACA,M;AACA,e;AACA,E;;AAEA,+B;AACA,0B;AACA,wB;AACA,M;AACA,+C;AACA,E;;AAEA,sE;AACA,6B;AACA,uB;AACA,Q;AACA,kC;AACA,8B;AACA,G;;AAEA,mC;AACA,oD;AACA,K;AACA,E;;AAEA,+C;AACA,iB;AACA,gB;AACA,qB;;AAEA,0B;AACA,gC;;AAEA,sD;AACA,yC;AACA,Q;AACA,+B;AACA,qE;AACA,wE;AACA,K;AACA,G;;AAEA,iC;;AAEA,kD;;AAEA,oD;AACA,qD;AACA,wD;AACA,I;;AAEA,mB;AACA,qC;AACA,G;;AAEA,sC;AACA,kE;;AAEA,8C;;AAEA,qB;AACA,E;;AAEA,G;AACA,6C;AACA,E;AACA,2E;AACA,2E;AACA,G;;AAEA,0C;AACA,iB;AACA,yB;AACA,E;;AAEA,wC;AACA,iB;AACA,iD;AACA,E;;AAEA,mC;AACA,gE;AACA,E;;AAEA,iC;AACA,oB;AACA,+C;AACA,kC;AACA,c;AACA,E;;AAEA,oC;AACA,iC;AACA,U;AACA,yC;AACA,kB;AACA,mD;AACA,iB;AACA,G;;AAEA,c;AACA,E;;;;;;;;;;;;;;;;;;;AC/LA,E;AACA,6E;AACA,+E;AACA,6E;AACA,kE;AACA,G;;AAEA,0C;AACA,W;;AAEA,6C;;AAEA,gC;AACA,iE;;AAEA,4B;AACA,mC;;AAEA,yC;AACA,sC;;AAEA,uB;AACA,2B;;AAEA,2E;AACA,gD;;AAEA,mB;AACA,yC;AACA,uC;;AAEA,8C;AACA,uC;AACA,M;AACA,2B;;AAEA,iB;AACA,E;;AAEA,mB;AACA,qB;;AAEA,K;AACA,uB;AACA,I;AACA,qB;AACA,iB;AACA,K;;AAEA,wB;AACA,mB;AACA,Y;AACA,+B;;AAEA,mB;;AAEA,8C;AACA,kC;AACA,Y;AACA,8B;AACA,gC;AACA,2C;AACA,iC;AACA,4B;AACA,iB;AACA,iD;AACA,kE;AACA,iE;AACA,gC;AACA,qB;AACA,uC;AACA,qB;AACA,uC;AACA,+B;AACA,wE;AACA,iC;AACA,W;AACA,S;AACA,oC;AACA,gC;AACA,M;AACA,2E;AACA,K;;AAEA,gB;AACA,I;;AAEA,K;AACA,0E;AACA,8C;AACA,I;AACA,yB;AACA,oB;AACA,gB;AACA,K;;AAEA,2B;AACA,2B;;AAEA,mB;AACA,2B;AACA,mB;AACA,wB;AACA,W;AACA,c;;AAEA,W;AACA,oG;;AAEA,mD;AACA,wB;AACA,wE;AACA,gB;AACA,4D;AACA,mC;AACA,Y;AACA,2B;AACA,K;;AAEA,2B;;AAEA,qC;AACA,oB;AACA,8C;;AAEA,qC;;AAEA,sB;AACA,6D;AACA,4C;AACA,kE;AACA,S;AACA,K;;AAEA,kB;AACA,I;;AAEA,kC;AACA,sC;;AAEA,oC;;AAEA,6C;AACA,sE;;AAEA,sC;AACA,wD;;AAEA,+B;AACA,wB;;AAEA,gB;AACA,I;;AAEA,K;AACA,0D;AACA,I;AACA,yB;AACA,uB;AACA,gB;AACA,K;AACA,yB;AACA,kD;AACA,I;;AAEA,yB;AACA,kD;AACA,I;;AAEA,uC;AACA,a;AACA,sB;AACA,c;AACA,yB;AACA,gC;AACA,Y;AACA,a;AACA,gC;;AAEA,4B;AACA,0B;AACA,0B;AACA,wB;;AAEA,iC;AACA,4E;AACA,Y;AACA,8B;AACA,iB;AACA,iD;AACA,2E;AACA,gC;AACA,gC;AACA,0D;;AAEA,8C;AACA,yB;AACA,yC;AACA,qC;AACA,6H;AACA,qB;AACA,kI;AACA,a;;AAEA,qE;AACA,mF;AACA,iD;AACA,yB;AACA,uC;AACA,W;AACA,S;AACA,iB;AACA,gB;AACA,4B;AACA,+D;AACA,8B;AACA,6E;AACA,+B;AACA,uE;AACA,a;;AAEA,6D;AACA,oE;AACA,iD;AACA,yB;AACA,W;AACA,U;;AAEA,8B;AACA,4D;AACA,uE;AACA,qB;;AAEA,kC;AACA,qC;AACA,O;;AAEA,iB;AACA,gD;AACA,uB;AACA,iD;AACA,O;AACA,K;;AAEA,yE;AACA,4D;AACA,oE;;AAEA,yC;AACA,I;;AAEA,oC;AACA,yC;AACA,I;;AAEA,mC;AACA,0C;AACA,wB;AACA,wC;AACA,uC;AACA,I;;AAEA,2C;AACA,oB;AACA,e;AACA,uB;AACA,kB;AACA,c;AACA,kB;;AAEA,0C;AACA,mC;AACA,gC;;AAEA,0C;AACA,0C;AACA,8C;AACA,wB;AACA,sD;AACA,O;;AAEA,wB;AACA,M;;AAEA,8E;AACA,2C;AACA,yC;AACA,2C;AACA,iD;AACA,8C;AACA,iB;AACA,kB;AACA,0B;AACA,+B;AACA,O;AACA,I;AACA,wD;AACA,0B;AACA,qD;AACA,0D;AACA,gD;AACA,wB;AACA,K;;AAEA,0E;AACA,0B;;AAEA,oB;AACA,yE;;AAEA,4B;AACA,kD;AACA,0B;AACA,O;AACA,K;;AAEA,8D;AACA,wC;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;;AC/TA,+E;AACA,yB;AACA,+E;;AAEA,G;AACA,oD;AACA,G;;AAEA,0C;AACA,kB;;AAEA,yC;;AAEA,kC;AACA,oD;AACA,I;;AAEA,+B;AACA,6B;AACA,2B;AACA,qC;AACA,yC;AACA,8C;AACA,kB;;AAEA,6C;AACA,iD;AACA,+C;AACA,iD;AACA,E;;AAEA,iC;AACA,mC;AACA,E;AACA,uC;AACA,+B;AACA,mC;;AAEA,iD;AACA,qB;;AAEA,yB;AACA,gF;AACA,M;AACA,6D;AACA,uD;AACA,M;;AAEA,iE;AACA,4C;AACA,sB;AACA,wE;;AAEA,sF;;AAEA,oD;AACA,uB;AACA,c;AACA,sB;AACA,K;AACA,I;;AAEA,oB;AACA,uC;AACA,I;;AAEA,uB;AACA,uC;AACA,I;;AAEA,oB;AACA,wB;AACA,G;AACA,E;;AAEA,+B;AACA,K;AACA,qC;AACA,I;AACA,yE;AACA,K;;AAEA,iC;AACA,iE;AACA,uB;AACA,M;AACA,Q;AACA,8E;AACA,mB;;AAEA,wB;AACA,uD;AACA,8C;;AAEA,mB;AACA,iD;AACA,kC;AACA,a;AACA,O;AACA,uC;AACA,6C;AACA,iC;AACA,S;AACA,O;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;ACzGA,+E;AACA,gB;AACA,+E;AACA,iC;AACA,kB;AACA,E;AACA,0B;;AAEA,K;AACA,oE;AACA,6B;AACA,I;AACA,gB;AACA,K;AACA,mB;AACA,E;AACA,yB;AACA,kF;AACA,E;;AAEA,8D;;AAEA,wB;AACA,0B;;AAEA,K;AACA,4E;AACA,wE;AACA,I;AACA,4B;AACA,yB;AACA,gB;AACA,K;AACA,E;AACA,iC;AACA,oB;AACA,I;AACA,sC;AACA,oC;AACA,I;AACA,4C;AACA,kD;AACA,+B;AACA,kE;AACA,mC;AACA,W;AACA,Q;AACA,kC;AACA,O;AACA,O;AACA,I;AACA,gB;AACA,I;;;AAGA,K;AACA,I;AACA,kE;AACA,iF;AACA,I;AACA,wE;AACA,uE;AACA,6C;AACA,yB;AACA,gB;AACA,I;AACA,K;AACA,E;AACA,0C;AACA,2B;;AAEA,qB;AACA,iD;AACA,uB;AACA,qD;AACA,M;AACA,iE;AACA,I;AACA,gB;AACA,I;AACA,E;AACA,iC;AACA,+C;AACA,I;;AAEA,mC;AACA,iD;AACA,I;AACA,E;AACA,kC;AACA,gD;AACA,I;AACA,E;AACA,mC;AACA,iD;AACA,I;AACA,E;AACA,K;AACA,I;AACA,uE;AACA,wD;AACA,I;AACA,wE;AACA,sE;AACA,0D;AACA,gB;AACA,I;AACA,K;AACA,I;AACA,kC;AACA,mB;AACA,I;AACA,oD;AACA,iC;AACA,M;AACA,4D;AACA,e;AACA,M;AACA,0D;AACA,e;AACA,M;AACA,4B;AACA,O;AACA,I;AACA,iB;AACA,I;AACA,E;;AAEA,K;AACA,+E;AACA,+C;AACA,I;AACA,a;AACA,8B;AACA,4B;AACA,S;AACA,I;AACA,0B;AACA,0B;AACA,iB;AACA,K;;AAEA,sB;AACA,kC;AACA,6D;AACA,kB;AACA,gB;AACA,I;;AAEA,K;AACA,+E;AACA,iE;AACA,I;AACA,+C;AACA,iE;AACA,oB;AACA,gB;AACA,K;;AAEA,mC;AACA,c;;AAEA,mE;AACA,I;AACA,iC;AACA,sB;AACA,Q;AACA,6C;;AAEA,8B;AACA,4B;AACA,iB;AACA,I;;AAEA,+C;AACA,uC;AACA,qB;AACA,4I;AACA,gD;AACA,I;;AAEA,8C;AACA,uC;AACA,sB;AACA,yI;AACA,+C;AACA,I;;AAEA,0C;AACA,mB;AACA,4B;AACA,a;AACA,kB;AACA,qD;AACA,c;;AAEA,sB;AACA,0B;;AAEA,mB;AACA,mD;AACA,O;;AAEA,6B;AACA,mC;AACA,iD;;AAEA,4D;AACA,iC;AACA,c;AACA,e;AACA,O;AACA,K;;AAEA,W;AACA,I;;AAEA,kC;AACA,2C;AACA,I;;AAEA,yC;AACA,mD;AACA,I;;AAEA,6C;AACA,sE;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;;ACpOA,qD;AACA,4B;AACA,iE;AACA,wC;AACA,0C;AACA,kC;AACA,I;;AAEA,oB;AACA,mB;AACA,oC;;AAEA,S;AACA,+E;;AAEA,0B;AACA,iH;;AAEA,2B;;AAEA,8B;;AAEA,yB;AACA,gC;AACA,e;AACA,O;;AAEA,wB;AACA,6B;AACA,8B;AACA,e;AACA,0B;AACA,K;AACA,I;;AAEA,uB;AACA,wB;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;ACtCA,qC;AACA,kC;;AAEA,kB;;AAEA,mB;AACA,Y;;AAEA,sD;AACA,6C;AACA,Q;AACA,2C;AACA,C;;AAEA,yC;AACA,mC;AACA,oB;AACA,8D;AACA,gC;AACA,8B;AACA,6C;AACA,uB;AACA,S;AACA,O;AACA,I;;AAEA,sB;AACA,mB;AACA,2B;AACA,gC;AACA,yC;AACA,I;;AAEA,wC;AACA,oB;AACA,uB;AACA,8B;AACA,qB;AACA,sB;AACA,kB;AACA,S;AACA,a;AACA,I;;AAEA,kC;AACA,oB;AACA,sD;;AAEA,0D;;AAEA,+D;AACA,oC;AACA,4D;AACA,a;AACA,K;;AAEA,gC;AACA,iD;;AAEA,yC;AACA,gC;AACA,qB;;AAEA,gD;AACA,2B;AACA,K;AACA,I;;AAEA,qB;AACA,I;;AAEA,yC;AACA,mB;AACA,I;;AAEA,6C;AACA,mB;AACA,G;AACA,G;;AAEA,0B","sourcesContent":["/**\n * Utility methods available privately to the package.\n */\n\nUtils = {};\n\n/**\n * Returns global on node or window in the browser.\n */\n\nUtils.global = function () {\n  if (typeof window !== 'undefined')\n    return window;\n  else if (typeof global !== 'undefined')\n    return global;\n  else\n    return null;\n};\n\n/**\n * Given the name of a property, resolves to the value. Works with namespacing\n * too. If first parameter is already a value that isn't a string it's returned\n * immediately.\n *\n * Examples:\n *  'SomeClass' => window.SomeClass || global.someClass\n *  'App.namespace.SomeClass' => window.App.namespace.SomeClass\n *\n * @param {String|Object} nameOrValue\n */\n\nUtils.resolveValue = function (nameOrValue) {\n  var global = Utils.global()\n    , parts\n    , ptr;\n\n  if (_.isString(nameOrValue)) {\n    parts = nameOrValue.split('.')\n    ptr = global;\n    for (var i = 0; i < parts.length; i++) {\n      ptr = ptr[parts[i]];\n      if (!ptr)\n        return undefined;\n    }\n  } else {\n    ptr = nameOrValue;\n  }\n\n  // final position of ptr should be the resolved value\n  return ptr;\n};\n\nUtils.hasOwnProperty = function (obj, key) {\n  var prop = {}.hasOwnProperty;\n  return prop.call(obj, key);\n};\n\n/**\n * Don't mess with this function. It's exactly the same as the compiled\n * coffeescript mechanism. If you change it we can't guarantee that our code\n * will work when used with Coffeescript. One exception is putting in a runtime\n * check that both child and parent are of type Function.\n */\n\nUtils.inherits = function (child, parent) {\n  if (Utils.typeOf(child) !== '[object Function]')\n    throw new Error('First parameter to Utils.inherits must be a function');\n   \n  if (Utils.typeOf(parent) !== '[object Function]')\n    throw new Error('Second parameter to Utils.inherits must be a function');\n\n  for (var key in parent) {\n    if (Utils.hasOwnProperty(parent, key))\n      child[key] = parent[key];\n  }\n\n  function ctor () {\n    this.constructor = child;\n  }\n\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n  child.__super__ = parent.prototype;\n  return child;\n};\n\nUtils.toArray = function (obj) {\n  if (!obj)\n    return [];\n  else if (Utils.typeOf(obj) !== '[object Array]')\n    return [obj];\n  else\n    return obj;\n};\n\nUtils.typeOf = function (obj) {\n  if (obj && obj.typeName)\n    return obj.typeName;\n  else\n    return Object.prototype.toString.call(obj);\n};\n\nUtils.extend = function (Super, definition, onBeforeExtendPrototype) {\n  if (arguments.length === 1)\n    definition = Super;\n  else {\n    definition = definition || {};\n    definition.extend = Super;\n  }\n\n  return Utils.create(definition, {\n    onBeforeExtendPrototype: onBeforeExtendPrototype\n  });\n};\n\nUtils.create = function (definition, options) {\n  var Constructor\n    , extendFrom\n    , savedPrototype;\n\n  options = options || {};\n  definition = definition || {};\n\n  if (Utils.hasOwnProperty(definition, 'constructor'))\n    Constructor = definition.constructor;\n  else {\n    Constructor = function () {\n      if (Constructor.__super__ && Constructor.__super__.constructor)\n        return Constructor.__super__.constructor.apply(this, arguments);\n    }\n  }\n\n  extendFrom = definition.extend;\n\n  if (definition.extend) delete definition.extend;\n\n  var inherit = function (Child, Super, prototype) {\n    Utils.inherits(Child, Utils.resolveValue(Super));\n    if (prototype) _.extend(Child.prototype, prototype);\n  };\n\n  if (extendFrom) {\n    inherit(Constructor, extendFrom);\n  }\n\n  if (options.onBeforeExtendPrototype)\n    options.onBeforeExtendPrototype.call(Constructor, definition);\n\n  _.extend(Constructor.prototype, definition);\n\n  return Constructor;\n};\n\n/**\n * Assert that the given condition is truthy.\n *\n * @param {Boolean} condition The boolean condition to test for truthiness.\n * @param {String} msg The error message to show if the condition is falsy.\n */\n\nUtils.assert = function (condition, msg) {\n  if (!condition)\n    throw new Error(msg);\n};\n\nUtils.warn = function (condition, msg) {\n  if (!condition)\n    console && console.warn && console.warn(msg);\n};\n\nUtils.capitalize = function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1, str.length);\n};\n\nUtils.classify = function (str) {\n  var re = /_|-|\\./;\n  return _.map(str.split(re), function (word) {\n    return Utils.capitalize(word);\n  }).join('');\n};\n\nUtils.pick = function (/* args */) {\n  var args = _.toArray(arguments)\n    , arg;\n  for (var i = 0; i < args.length; i++) {\n    arg = args[i];\n    if (typeof arg !== 'undefined' && arg !== null)\n      return arg;\n  }\n\n  return null;\n};\n","/*\n * Inspiration and some code for the compilation of routes comes from pagejs.\n * The original has been modified to better handle hash fragments, and to store\n * the regular expression on the Route instance. Also, the resolve method has\n * been added to return a resolved path given a parameters object.\n */\n\nRoute = function (router, name, options) {\n  var path;\n\n  Utils.assert(router instanceof IronRouter);\n\n  Utils.assert(_.isString(name),\n    'Route constructor requires a name as the second parameter');\n\n  if (_.isFunction(options))\n    options = { handler: options };\n\n  options = this.options = options || {};\n  path = options.path || ('/' + name);\n\n  this.router = router;\n  this.originalPath = path;\n\n  if (_.isString(this.originalPath) && this.originalPath.charAt(0) !== '/')\n    this.originalPath = '/' + this.originalPath;\n\n  this.name = name;\n  this.where = options.where || 'client';\n  this.controller = options.controller;\n\n  if (typeof options.reactive !== 'undefined')\n    this.isReactive = options.reactive;\n  else\n    this.isReactive = true;\n\n  this.compile();\n};\n\nRoute.prototype = {\n  constructor: Route,\n\n  /**\n   * Compile the path. \n   *\n   *  @return {Route}\n   *  @api public\n   */\n\n  compile: function () {\n    var self = this\n      , path\n      , options = self.options;\n\n    this.keys = [];\n\n    if (self.originalPath instanceof RegExp) {\n      self.re = self.originalPath;\n    } else {\n      path = self.originalPath\n        .replace(/(.)\\/$/, '$1')\n        .concat(options.strict ? '' : '/?')\n        .replace(/\\/\\(/g, '(?:/')\n        .replace(/#/, '/?#')\n        .replace(\n          /(\\/)?(\\.)?:(\\w+)(?:(\\(.*?\\)))?(\\?)?/g,\n          function (match, slash, format, key, capture, optional){\n            self.keys.push({ name: key, optional: !! optional });\n            slash = slash || '';\n            return ''\n              + (optional ? '' : slash)\n              + '(?:'\n              + (optional ? slash : '')\n              + (format || '') \n              + (capture || (format && '([^/.]+?)' || '([^/]+?)')) + ')'\n              + (optional || '');\n          }\n        )\n        .replace(/([\\/.])/g, '\\\\$1')\n        .replace(/\\*/g, '(.*)');\n      \n      self.re = new RegExp('^' + path + '$', options.sensitive ? '' : 'i');\n    }\n\n    return this;\n  },\n\n  /**\n   * Returns an array of parameters given a path. The array may have named\n   * properties in addition to indexed values.\n   *\n   * @param {String} path\n   * @return {Array}\n   * @api public\n   */\n\n  params: function (path) {\n    if (!path) return null;\n\n    var params = []\n      , m = this.exec(path)\n      , queryString\n      , keys = this.keys\n      , key\n      , value;\n\n    if (!m)\n      throw new Error('The route named \"' + this.name + '\" does not match the path \"' + path + '\"');\n\n    for (var i = 1, len = m.length; i < len; ++i) {\n      key = keys[i - 1];\n      value = typeof m[i] == 'string' ? decodeURIComponent(m[i]) : m[i];\n      if (key) {\n        params[key.name] = params[key.name] !== undefined ? \n          params[key.name] : value;\n      } else\n        params.push(value);\n    }\n\n    path = decodeURI(path);\n\n    queryString = path.split('?')[1];\n    if (queryString)\n      queryString = queryString.split('#')[0];\n\n    params.hash = path.split('#')[1];\n\n    if (queryString) {\n      _.each(queryString.split('&'), function (paramString) {\n        paramParts = paramString.split('=');\n        params[paramParts[0]] = decodeURIComponent(paramParts[1]);\n      });\n    }\n\n    return params;\n  },\n\n  normalizePath: function (path) {\n    var origin = Meteor.absoluteUrl();\n\n    path = path.replace(origin, '');\n\n    var queryStringIndex = path.indexOf('?');\n    path = ~queryStringIndex ? path.slice(0, queryStringIndex) : path;\n\n    var hashIndex = path.indexOf('#');\n    path = ~hashIndex ? path.slice(0, hashIndex) : path;\n\n    if (path.charAt(0) !== '/')\n      path = '/' + path;\n\n    return path;\n  },\n\n  /**\n   * Returns true if the path matches and false otherwise.\n   *\n   * @param {String} path\n   * @return {Boolean} \n   * @api public\n   */\n  test: function (path) {\n    return this.re.test(this.normalizePath(path));\n  },\n\n  exec: function (path) {\n    return this.re.exec(this.normalizePath(path));\n  },\n\n  resolve: function (params, options) {\n    var value\n      , isValueDefined\n      , result\n      , wildCardCount = 0\n      , path = this.originalPath\n      , hash\n      , query\n      , isMissingParams = false;\n\n    options = options || {};\n    params = params || [];\n    query = options.query;\n    hash = options.hash;\n\n    if (path instanceof RegExp) {\n      throw new Error('Cannot currently resolve a regular expression path');\n    } else {\n      path = this.originalPath\n        .replace(\n          /(\\/)?(\\.)?:(\\w+)(?:(\\(.*?\\)))?(\\?)?/g,\n          function (match, slash, format, key, capture, optional, offset) {\n            slash = slash || '';\n            value = params[key];\n            isValueDefined = typeof value !== 'undefined';\n\n            if (optional && !isValueDefined) {\n              value = '';\n            } else if (!isValueDefined) {\n              isMissingParams = true;\n              console.warn('You called Route.prototype.resolve with a missing parameter. \"' + key + '\" not found in params');\n              return;\n              //throw new Error('You called Route.prototype.resolve with a missing parameter. \"' + key + '\" not found in params');\n            }\n\n            value = _.isFunction(value) ? value.call(params) : value;\n            var escapedValue = _.map(String(value).split('/'), function (segment) {\n              return encodeURIComponent(segment);\n            }).join('/');\n            return slash + escapedValue\n          }\n        )\n        .replace(\n          /\\*/g,\n          function (match) {\n            if (typeof params[wildCardCount] === 'undefined') {\n              throw new Error(\n                'You are trying to access a wild card parameter at index ' + \n                wildCardCount +\n                ' but the value of params at that index is undefined');\n            }\n\n            var paramValue = String(params[wildCardCount++]);\n            return _.map(paramValue.split('/'), function (segment) {\n              return encodeURIComponent(segment);\n            }).join('/');\n          }\n        );\n\n      if (_.isObject(query)) {\n        query = _.map(_.pairs(query), function (queryPart) {\n          return queryPart[0] + '=' + encodeURIComponent(queryPart[1]);\n        }).join('&');\n\n        if (query && query.length)\n          path = path + '/?' + query;\n      }\n\n      if (hash) {\n        hash = encodeURI(hash.replace('#', ''));\n        path = query ? \n          path + '#' + hash : path + '/#' + hash;\n      }\n    }\n\n    // Because of optional possibly empty segments we normalize path here\n    path = path.replace(/\\/+/g, '/'); // Multiple / -> one /\n    path = path.replace(/^(.+)\\/$/g, '$1'); // Removal of trailing /\n\n    return isMissingParams ? null : path;\n  },\n\n  path: function (params, options) {\n    return this.resolve(params, options);\n  },\n\n  url: function (params, options) {\n    var path = this.path(params, options);\n    if (path[0] === '/')\n      path = path.slice(1, path.length);\n    return Meteor.absoluteUrl() + path;\n  },\n\n  getController: function (path, options) {\n    var self = this;\n    var handler\n      , controllerClass\n      , controller\n      , action\n      , routeName;\n\n    var resolveValue = Utils.resolveValue;\n    var classify = Utils.classify; \n    var toArray = Utils.toArray;\n\n    var findController = function (name) {\n      var controller = resolveValue(name);\n      if (typeof controller === 'undefined') {\n        throw new Error(\n          'controller \"' + name + '\" is not defined');\n      }\n\n      return controller;\n    };\n\n    options = _.extend({}, this.router.options, this.options, options || {}, {\n      before: toArray(this.options.before),\n      after: toArray(this.options.after),\n      unload: toArray(this.options.unload),\n      waitOn: toArray(this.router.options.waitOn)\n        .concat(toArray(this.options.waitOn)),\n      path: path,\n      route: this,\n      router: this.router,\n      params: this.params(path)\n    });\n    \n    // case 1: controller option is defined on the route\n    if (this.controller) {\n      controllerClass = _.isString(this.controller) ?\n        findController(this.controller) : this.controller;\n      controller = new controllerClass(options);\n      return controller;\n    }\n\n    // case 2: intelligently find the controller class in global namespace\n    routeName = this.name;\n\n    if (routeName) {\n      controllerClass = resolveValue(classify(routeName + 'Controller'));\n\n      if (controllerClass) {\n        controller = new controllerClass(options);\n        return controller;\n      }\n    }\n\n    // case 3: nothing found so create an anonymous controller\n    return new RouteController(options);\n  }\n};\n","/*****************************************************************************/\n/* IronRouteController */\n/*****************************************************************************/\n\n/**\n * Base class for client and server RouteController.\n */\n\nIronRouteController = function (options) {\n  var self = this;\n\n  options = this.options = options || {};\n\n  var getOption = function (key) {\n    return Utils.pick(self.options[key], self[key]);\n  };\n\n  this.router = options.router;\n  this.route = options.route;\n  this.path = options.path;\n  this.params = options.params || [];\n  this.where = options.where || 'client';\n  this.action = options.action || this.action;\n  this.hooks = {};\n\n  options.load = Utils.toArray(options.load);\n  options.before = Utils.toArray(options.before);\n  options.after = Utils.toArray(options.after);\n  options.unload = Utils.toArray(options.unload);\n};\n\nIronRouteController.prototype = {\n  constructor: IronRouteController,\n  \n  runHooks: function (hookName, more) {\n    var ctor = this.constructor\n      , more = Utils.toArray(more);\n\n    var collectInheritedHooks = function (ctor) {\n      var hooks = [];\n\n      if (ctor.__super__)\n        hooks = hooks.concat(collectInheritedHooks(ctor.__super__.constructor));\n      \n      return Utils.hasOwnProperty(ctor.prototype, hookName) ?\n        hooks.concat(ctor.prototype[hookName]) : hooks;\n    };\n\n    var prototypeHooks = collectInheritedHooks(this.constructor);\n    var routeHooks = this.options[hookName];\n    var globalHooks = \n      this.route ? this.router.getHooks(hookName, this.route.name) : [];\n\n    var allHooks = globalHooks.concat(routeHooks).concat(prototypeHooks).concat(more);\n\n    for (var i = 0, hook; hook = allHooks[i]; i++) {\n      if (this.stopped)\n        break;\n      hook.call(this);\n    }\n  },\n\n  run: function () {\n    throw new Error('not implemented');\n  },\n\n  action: function () {\n    throw new Error('not implemented');\n  },\n\n  stop: function() {\n    this.stopped = true;\n  }\n};\n\n_.extend(IronRouteController, {\n  /**\n   * Inherit from IronRouteController\n   *\n   * @param {Object} definition Prototype properties for inherited class.\n   */\n\n  extend: function (definition) {\n    return Utils.extend(this, definition, function (definition) {\n      var klass = this;\n      \n      /*\n        Allow calling a class method from javascript, directly in the subclass\n        definition.\n\n        Instead of this:\n          MyController = RouteController.extend({...});\n          MyController.before(function () {});\n\n        You can do:\n          MyController = RouteController.extend({\n            before: function () {}\n          });\n       \n        And in Coffeescript you can do:\n         MyController extends RouteController\n           @before function () {}\n       */\n    });\n  }\n});\n","/*****************************************************************************/\n/* IronRouter */\n/*****************************************************************************/\nIronRouter = function (options) {\n  var self = this;\n  \n  this.configure(options);\n\n  /**\n   * The routes array which doubles as a named route index by adding\n   * properties to the array.\n   *\n   * @api public\n   */\n  this.routes = [];\n  \n  this._globalHooks = {};\n  _.each(IronRouter.HOOK_TYPES, function(type) { self._globalHooks[type] = []; });\n};\n\nIronRouter.HOOK_TYPES = ['load', 'before', 'after', 'unload'];\n\nIronRouter.prototype = {\n  constructor: IronRouter,\n\n  /**\n   * Configure instance with options. This can be called at any time. If the\n   * instance options object hasn't been created yet it is created here.\n   *\n   * @param {Object} options\n   * @return {IronRouter}\n   * @api public\n   */\n  \n  configure: function (options) {\n    var self = this;\n    \n    this.options = this.options || {};\n    _.extend(this.options, options);\n    \n    // e.g. before: fn OR before: [fn1, fn2]\n    _.each(IronRouter.HOOK_TYPES, function(type) {\n      if (self.options[type]) {\n        _.each(Utils.toArray(self.options[type]), function(hook) {\n          self.addHook(type, hook);\n        });\n        \n        delete self.options[type];\n      }\n    });\n    \n    return this;\n  },\n\n\n  /**\n   *\n   * Add a hook to all routes. The hooks will apply to all routes,\n   * unless you name routes to include or exclude via `only` and `except` options\n   *\n   * @param {String} [type] one of 'load', 'unload', 'before' or 'after'\n   * @param {Object} [options] Options to controll the hooks [optional]\n   * @param {Function} [hook] Callback to run\n   * @return {IronRouter}\n   * @api public\n   *\n   */\n  \n  addHook: function(type, hook, options) {\n    options = options || {}\n\n    if (options.only)\n      options.only = Utils.toArray(options.only);\n    if (options.except)\n      options.except = Utils.toArray(options.except);\n      \n    this._globalHooks[type].push({options: options, hook: hook});\n    \n    return this;\n  },\n  \n  load: function(hook, options) {\n    return this.addHook('load', hook, options);\n  },\n\n  before: function(hook, options) {\n    return this.addHook('before', hook, options);\n  },\n  \n  after: function(hook, options) {\n    return this.addHook('after', hook, options);\n  },\n  \n  unload: function(hook, options) {\n    return this.addHook('unload', hook, options);\n  },\n  \n  /**\n   *\n   * Fetch the list of global hooks that apply to the given route name.\n   * Hooks are defined by the .addHook() function above.\n   *\n   * @param {String} [type] one of 'load', 'unload', 'before' or 'after'\n   * @param {String} [name] the name of the route we are interested in\n   * @return {[Function]} [hooks] an array of hooks to run\n   * @api public\n   *\n   */\n    \n  getHooks: function(type, name) {\n    var hooks = [];\n    \n    _.each(this._globalHooks[type], function(hook) {\n      var options = hook.options;\n      \n      if (options.except && _.include(options.except, name))\n        return;\n      \n      if (options.only && ! _.include(options.only, name))\n        return;\n      \n      hooks.push(hook.hook);\n    });\n    \n    return hooks;\n  },\n  \n\n  /**\n   * Convenience function to define a bunch of routes at once. In the future we\n   * might call the callback with a custom dsl.\n   *\n   * Example:\n   *  Router.map(function () {\n   *    this.route('posts');\n   *  });\n   *\n   *  @param {Function} cb\n   *  @return {IronRouter}\n   *  @api public\n   */\n\n  map: function (cb) {\n    Utils.assert(_.isFunction(cb),\n           'map requires a function as the first parameter');\n    cb.call(this);\n    return this;\n  },\n\n  /**\n   * Define a new route. You must name the route, but as a second parameter you\n   * can either provide an object of options or a Route instance.\n   *\n   * @param {String} name The name of the route\n   * @param {Object} [options] Options to pass along to the route\n   * @return {Route}\n   * @api public\n   */\n\n  route: function (name, options) {\n    var route;\n\n    Utils.assert(_.isString(name), 'name is a required parameter');\n    \n    if (options instanceof Route)\n      route = options;\n    else\n      route = new Route(this, name, options);\n\n    this.routes[name] = route;\n    this.routes.push(route);\n    return route;\n  },\n\n  path: function (routeName, params, options) {\n    var route = this.routes[routeName];\n    Utils.warn(route,\n     'You called Router.path for a route named ' + routeName + ' but that that route doesn\\'t seem to exist. Are you sure you created it?');\n    return route && route.path(params, options);\n  },\n\n  url: function (routeName, params, options) {\n    var route = this.routes[routeName];\n    Utils.warn(route, \n      'You called Router.url for a route named \"' + routeName + '\" but that route doesn\\'t seem to exist. Are you sure you created it?');\n    return route && route.url(params, options);\n  },\n\n  dispatch: function (path, options, cb) {\n    var self = this\n      , routes = self.routes\n      , route\n      , controller\n      , where = Meteor.isClient ? 'client' : 'server'\n      , i = 0;\n\n    function next () {\n      route = routes[i++];\n\n      if (!route) {\n        return self.onRouteNotFound(path, options);\n      }\n\n      if (route.test(path)) {\n        if (route.where !== where) \n          return self.onUnhandled(path, options);\n\n        var controller = route.getController(path, options);\n        self.run(controller, cb);\n      } else {\n        next();\n      }\n    }\n\n    next();\n  },\n\n  run: function (controller, cb) {\n    throw new Error('run not implemented');\n  },\n\n  onUnhandled: function (path, options) {\n    throw new Error('onUnhandled not implemented');\n  },\n\n  onRouteNotFound: function (path, options) {\n    throw new Error('Oh no! No route found for path: \"' + path + '\"');\n  }\n};\n","RouteController = Utils.extend(IronRouteController, {\n  constructor: function () {\n    RouteController.__super__.constructor.apply(this, arguments);\n    this.request = this.options.request;\n    this.response = this.options.response;\n    this.next = this.options.next;\n  },\n\n  run: function () {\n    var self = this\n      , args = _.toArray(arguments);\n\n    try {\n      var action = _.isFunction(this.action) ? this.action : this[this.action];\n\n      Utils.assert(action,\n        \"Uh oh, you don't seem to have an action named \\\"\" + this.action + \"\\\" defined on your RouteController\");\n\n      this.stopped = false;\n\n      this.runHooks('before');\n\n      if (this.stopped) {\n        this.isFirstRun = false;\n        return;\n      }\n\n      action.call(this);\n      this.runHooks('after');\n      this.isFirstRun = false;\n    } finally {\n      this.response.end();\n    }\n  },\n\n  action: function () {\n    this.response.end();\n  }\n});\n","var connect = Npm.require('connect');\nvar Fiber = Npm.require('fibers');\n\nvar root = global;\n\nvar connectHandlers\n  , connect;\n\nif (typeof __meteor_bootstrap__.app !== 'undefined') {\n  connectHandlers = __meteor_bootstrap__.app;\n} else {\n  connectHandlers = WebApp.connectHandlers;\n}\n\nServerRouter = Utils.extend(IronRouter, {\n  constructor: function (options) {\n    var self = this;\n    ServerRouter.__super__.constructor.apply(this, arguments);\n    Meteor.startup(function () {\n      setTimeout(function () {\n        if (self.options.autoStart !== false)\n          self.start();\n      });\n    });\n  },\n\n  start: function () {\n    connectHandlers\n      .use(connect.query())\n      .use(connect.bodyParser())\n      .use(_.bind(this.onRequest, this));\n  },\n\n  onRequest: function (req, res, next) {\n    var self = this;\n    Fiber(function () {\n      self.dispatch(req.url, {\n        request: req,\n        response: res,\n        next: next\n      });\n    }).run();\n  },\n\n  run: function (controller, cb) {\n    var self = this;\n    var where = Meteor.isClient ? 'client' : 'server';\n\n    Utils.assert(controller, 'run requires a controller');\n\n    // one last check to see if we should handle the route here\n    if (controller.where != where) {\n      self.onUnhandled(controller.path, controller.options);\n      return;\n    }\n\n    if (this._currentController)\n      this._currentController.runHooks('unload');\n\n    this._currentController = controller;\n    controller.runHooks('load');\n    controller.run();\n\n    if (controller == this._currentController) {\n      cb && cb(controller);\n    }\n  },\n\n  stop: function () {\n  },\n\n  onUnhandled: function (path, options) {\n    options.next();\n  },\n\n  onRouteNotFound: function (path, options) {\n    options.next();\n  }\n});\n\nRouter = new ServerRouter;\n"]}