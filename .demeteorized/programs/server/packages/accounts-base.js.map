{"version":3,"file":"/packages/accounts-base.js","sources":["accounts-base/accounts_common.js","accounts-base/accounts_server.js","accounts-base/url_server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA,c;;AAEA,qE;AACA,4B;AACA,uB;;AAEA,iD;AACA,uC;AACA,8E;AACA,6E;AACA,0D;AACA,mD;AACA,0D;AACA,qD;AACA,gF;AACA,S;AACA,sC;;AAEA,sE;AACA,kB;AACA,E;AACA,qE;AACA,+C;AACA,sE;AACA,oE;AACA,qD;AACA,E;AACA,iD;AACA,oC;AACA,uE;AACA,sB;AACA,0C;AACA,wD;AACA,uD;AACA,sE;AACA,mC;AACA,mC;AACA,yE;AACA,gB;AACA,E;AACA,qC;AACA,yE;AACA,6E;AACA,gF;AACA,2E;AACA,+B;AACA,wB;AACA,0D;AACA,+D;AACA,+E;AACA,sD;AACA,8E;AACA,6E;AACA,G;;AAEA,yB;AACA,2E;AACA,8E;AACA,0C;AACA,uC;AACA,8D;AACA,K;AACA,K;;AAEA,oC;AACA,qC;AACA,yB;AACA,qC;AACA,kE;AACA,c;AACA,8C;AACA,O;AACA,K;AACA,K;;AAEA,6E;AACA,4C;AACA,sB;AACA,oC;AACA,E;;AAEA,uE;AACA,kE;AACA,qD;AACA,E;AACA,2E;AACA,gE;AACA,c;;AAEA,uF;AACA,yE;AACA,wD;;AAEA,sE;AACA,oC;AACA,sD;AACA,6B;AACA,E;;AAEA,6E;AACA,6E;AACA,oC;AACA,sD;AACA,qD;AACA,6E;;AAEA,kC;AACA,oD;AACA,+D;AACA,E;;AAEA,6C;AACA,2E;AACA,gC;AACA,qE;AACA,E;;AAEA,8C;AACA,gD;AACA,4D;AACA,uC;AACA,qC;AACA,uD;AACA,E;;;;;;;;;;;;;;;;;;;AC3HA,G;AACA,gB;AACA,G;;AAEA,6B;AACA,sE;AACA,kE;AACA,oE;AACA,gE;AACA,kE;AACA,mE;AACA,kE;AACA,mE;AACA,oB;AACA,uD;AACA,yB;AACA,gH;AACA,kC;AACA,E;;AAEA,2B;AACA,+B;AACA,c;AACA,gB;AACA,sC;AACA,E;;AAEA,G;AACA,kB;AACA,G;;AAEA,8D;AACA,E;AACA,uE;AACA,uE;AACA,uC;AACA,mE;AACA,gF;AACA,8E;AACA,6E;AACA,W;AACA,kD;AACA,E;AACA,mD;AACA,8B;AACA,E;;AAEA,mC;AACA,mB;;;AAGA,oE;AACA,sE;AACA,0D;AACA,8C;AACA,kD;AACA,mC;AACA,kC;AACA,6B;AACA,oB;AACA,G;;AAEA,wE;AACA,E;;;AAGA,mE;AACA,8B;AACA,gB;AACA,2B;AACA,iE;AACA,+E;AACA,qB;AACA,4B;AACA,6E;AACA,wC;AACA,2B;AACA,8C;AACA,0B;AACA,gC;AACA,gE;AACA,K;AACA,kB;AACA,I;;AAEA,sB;AACA,4D;AACA,sD;AACA,6B;AACA,2C;AACA,yB;AACA,I;;AAEA,+E;AACA,0E;AACA,4E;AACA,0C;AACA,I;AACA,+D;AACA,mC;AACA,oB;AACA,kD;AACA,e;AACA,2C;AACA,O;AACA,O;AACA,e;AACA,iE;AACA,0E;AACA,+E;AACA,6E;AACA,c;AACA,oD;AACA,2D;AACA,+B;AACA,wC;AACA,e;AACA,wD;AACA,yD;AACA,U;AACA,0D;AACA,S;AACA,qC;AACA,gF;AACA,oC;AACA,0C;AACA,sD;AACA,mD;AACA,0E;AACA,6E;AACA,mB;AACA,c;AACA,8B;AACA,8D;AACA,Q;AACA,Y;AACA,gD;AACA,K;AACA,G;AACA,G;;AAEA,G;AACA,gB;AACA,G;;AAEA,yD;AACA,qB;;AAEA,2D;AACA,uC;AACA,6B;AACA,E;;AAEA,kE;AACA,uC;;AAEA,uE;AACA,kD;AACA,Y;AACA,W;;AAEA,0B;AACA,uB;AACA,M;AACA,wB;AACA,E;;AAEA,kD;AACA,wD;AACA,kC;AACA,6C;AACA,sC;AACA,K;AACA,G;;;AAGA,G;AACA,oB;AACA,G;AACA,mD;;AAEA,kC;AACA,iC;;AAEA,Y;AACA,kD;AACA,wC;AACA,E;;AAEA,yE;AACA,yD;AACA,oD;AACA,c;AACA,+C;AACA,qC;AACA,kB;AACA,M;AACA,kD;AACA,4C;AACA,G;AACA,E;;AAEA,mD;AACA,8D;AACA,E;;AAEA,6D;AACA,0C;;AAEA,iE;;AAEA,iB;AACA,mD;AACA,6C;AACA,yD;AACA,G;AACA,E;;AAEA,kE;AACA,Y;AACA,mD;AACA,mC;AACA,gD;AACA,wE;AACA,2C;AACA,wE;AACA,gF;AACA,yB;AACA,+B;AACA,W;AACA,S;AACA,K;AACA,K;AACA,E;;;AAGA,mC;AACA,iD;AACA,sB;AACA,qB;;AAEA,gC;AACA,mC;AACA,0D;AACA,K;;AAEA,c;AACA,0E;AACA,2B;AACA,G;;AAEA,yE;AACA,0C;AACA,K;;AAEA,2D;AACA,iC;AACA,iF;;AAEA,U;AACA,0B;AACA,+B;AACA,gB;AACA,I;AACA,G;;AAEA,+D;AACA,E;AACA,mD;AACA,gD;AACA,E;;AAEA,sE;AACA,sD;AACA,sD;AACA,+B;AACA,Y;AACA,4D;AACA,K;AACA,K;AACA,E;;AAEA,G;AACA,oB;AACA,G;;AAEA,wB;;AAEA,2E;AACA,gC;AACA,E;AACA,2D;AACA,qE;AACA,sE;AACA,4B;AACA,gF;AACA,6C;;AAEA,0E;AACA,qE;AACA,+E;AACA,G;;AAEA,sC;AACA,6C;AACA,+C;;;AAGA,+E;AACA,2B;AACA,4C;AACA,U;AACA,uE;AACA,uE;AACA,K;AACA,O;AACA,Y;AACA,sC;AACA,c;AACA,6C;AACA,6C;AACA,S;AACA,O;AACA,K;AACA,sB;AACA,0E;AACA,oB;AACA,E;;AAEA,6C;AACA,0D;AACA,yD;AACA,4B;AACA,8C;AACA,+B;AACA,G;AACA,E;;AAEA,sD;AACA,oE;;AAEA,G;AACA,qB;AACA,G;;AAEA,4B;AACA,yC;AACA,uB;AACA,uD;AACA,M;AACA,4B;AACA,E;;AAEA,4E;AACA,oC;AACA,sD;AACA,sB;AACA,mC;AACA,c;AACA,E;;AAEA,8B;AACA,mD;AACA,wD;AACA,8B;AACA,mE;AACA,4C;AACA,I;AACA,oE;AACA,iD;AACA,mE;AACA,iE;AACA,kE;AACA,iE;AACA,iB;AACA,mE;;AAEA,kB;AACA,mC;AACA,6D;AACA,sC;AACA,uE;AACA,+C;AACA,mD;AACA,0D;AACA,Q;AACA,wD;AACA,G;;AAEA,e;AACA,yB;AACA,+C;;AAEA,2E;AACA,yE;AACA,iE;AACA,yC;AACA,sD;AACA,U;AACA,oD;AACA,G;;AAEA,gD;AACA,wB;AACA,4D;AACA,K;;AAEA,O;AACA,8C;AACA,e;AACA,sC;AACA,yE;AACA,yC;AACA,0E;AACA,wB;AACA,mD;AACA,2D;AACA,4C;AACA,8D;AACA,yE;AACA,Y;AACA,G;;AAEA,gB;AACA,E;;AAEA,8B;AACA,4C;AACA,kC;AACA,E;;AAEA,oD;AACA,+D;AACA,+D;AACA,gC;AACA,gD;AACA,E;;AAEA,6E;AACA,qB;AACA,wC;AACA,+D;AACA,mB;AACA,8C;AACA,0B;AACA,oE;AACA,E;;AAEA,sE;AACA,0C;AACA,+D;AACA,c;AACA,gB;;AAEA,0B;AACA,gC;AACA,uD;AACA,4C;AACA,O;AACA,yC;AACA,iD;AACA,2D;AACA,6D;AACA,O;AACA,G;;AAEA,kB;AACA,gB;;AAEA,yB;AACA,kE;AACA,M;AACA,qE;AACA,G;;AAEA,G;AACA,yB;AACA,G;;AAEA,oE;AACA,E;AACA,0D;AACA,iE;AACA,iE;AACA,mE;AACA,2E;AACA,uB;AACA,mE;AACA,gC;AACA,E;AACA,0D;AACA,sC;AACA,mC;;AAEA,6D;AACA,oB;AACA,8E;AACA,uB;AACA,gC;AACA,oB;AACA,sE;;AAEA,0D;AACA,oB;AACA,uD;;AAEA,yD;AACA,wE;AACA,wE;AACA,qE;AACA,4E;AACA,6E;AACA,sE;AACA,4D;AACA,8B;AACA,sD;AACA,oE;AACA,U;AACA,4C;AACA,G;;AAEA,4C;;AAEA,a;AACA,6E;AACA,yE;AACA,6D;AACA,mE;AACA,0B;AACA,6D;AACA,sB;AACA,8C;AACA,8D;AACA,O;;AAEA,6E;AACA,2B;AACA,wB;AACA,e;AACA,sB;AACA,8D;AACA,Y;AACA,gC;AACA,mB;AACA,gE;AACA,M;AACA,U;AACA,6E;AACA,qB;AACA,0B;AACA,6C;AACA,sC;AACA,iD;AACA,G;AACA,E;;;AAGA,G;AACA,mB;AACA,G;;AAEA,mD;AACA,iC;AACA,oB;AACA,6B;AACA,yB;AACA,sD;AACA,U;AACA,gB;AACA,G;AACA,oD;;AAEA,iE;AACA,wD;AACA,qE;AACA,iE;AACA,kE;AACA,yB;AACA,kD;AACA,qC;AACA,E;;AAEA,6D;AACA,gE;AACA,8C;AACA,E;AACA,6B;AACA,8E;AACA,qF;AACA,gD;AACA,4C;AACA,0D;AACA,0C;AACA,sD;AACA,E;;AAEA,0B;AACA,+D;AACA,0B;AACA,8B;AACA,2D;AACA,4C;AACA,qD;AACA,0B;AACA,U;AACA,M;;AAEA,6C;AACA,wB;AACA,iC;AACA,6B;AACA,qE;AACA,c;AACA,oB;AACA,O;AACA,wD;;AAEA,gF;AACA,8E;AACA,6E;AACA,+E;AACA,gE;AACA,6C;AACA,mB;AACA,sB;AACA,6C;AACA,U;AACA,sB;;AAEA,+B;AACA,iB;AACA,iE;AACA,wD;AACA,K;AACA,C;;AAEA,oE;AACA,gE;AACA,6E;AACA,2E;;AAEA,oE;AACA,wD;AACA,gB;AACA,+C;AACA,6D;AACA,0E;AACA,yE;AACA,wB;AACA,2E;AACA,wE;AACA,0B;AACA,wB;AACA,2E;AACA,qD;AACA,K;AACA,gF;AACA,wF;AACA,wD;AACA,G;AACA,G;;;AAGA,G;AACA,sC;AACA,G;;AAEA,oB;AACA,oE;AACA,kB;AACA,qD;AACA,iC;AACA,4B;AACA,mB;;AAEA,iE;AACA,sE;AACA,0B;AACA,uD;AACA,mB;;AAEA,gB;AACA,I;AACA,wC;AACA,G;;AAEA,4B;AACA,8D;AACA,oE;AACA,8D;AACA,kD;AACA,6E;AACA,gB;AACA,oE;AACA,yC;AACA,4B;AACA,6E;;AAEA,G;AACA,qC;AACA,G;;AAEA,2D;AACA,uB;AACA,iC;AACA,e;AACA,qD;AACA,gD;AACA,Q;AACA,iB;AACA,qD;AACA,O;AACA,O;AACA,G;AACA,E;;AAEA,4B;AACA,6E;AACA,2E;AACA,gF;AACA,gF;AACA,0E;AACA,Y;AACA,iC;AACA,mD;AACA,M;AACA,4C;AACA,K;AACA,iC;AACA,0E;AACA,K;AACA,G;;AAEA,G;AACA,6B;AACA,G;;AAEA,gD;AACA,0D;AACA,E;;AAEA,8E;AACA,+C;AACA,kD;AACA,oD;AACA,oD;AACA,O;AACA,K;AACA,E;;AAEA,oE;AACA,wC;AACA,2B;AACA,sD;AACA,sD;AACA,8E;AACA,+E;AACA,6D;AACA,gE;AACA,K;AACA,sC;AACA,I;AACA,+B;AACA,oD;AACA,oE;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;AC9vBA,oD;;AAEA,mB;;AAEA,gD;AACA,yD;AACA,E;;AAEA,8C;AACA,uD;AACA,E;;AAEA,gD;AACA,yD;AACA,E","sourcesContent":["Accounts = {};\n\n// Currently this is read directly by packages like accounts-password\n// and accounts-ui-unstyled.\nAccounts._options = {};\n\n// how long (in days) until a login token expires\nvar DEFAULT_LOGIN_EXPIRATION_DAYS = 90;\n// Clients don't try to auto-login with a token that is going to expire within\n// .1 * DEFAULT_LOGIN_EXPIRATION_DAYS, capped at MIN_TOKEN_LIFETIME_CAP_SECS.\n// Tries to avoid abrupt disconnects from expiring tokens.\nvar MIN_TOKEN_LIFETIME_CAP_SECS = 3600; // one hour\n// how often (in milliseconds) we check for expired tokens\nEXPIRE_TOKENS_INTERVAL_MS = 600 * 1000; // 10 minutes\n// how long we wait before logging out clients when Meteor.logoutOtherClients is\n// called\nCONNECTION_CLOSE_DELAY_MS = 10 * 1000;\n\n// Set up config for the accounts system. Call this on both the client\n// and the server.\n//\n// XXX we should add some enforcement that this is called on both the\n// client and the server. Otherwise, a user can\n// 'forbidClientAccountCreation' only on the client and while it looks\n// like their app is secure, the server will still accept createUser\n// calls. https://github.com/meteor/meteor/issues/828\n//\n// @param options {Object} an object with fields:\n// - sendVerificationEmail {Boolean}\n//     Send email address verification emails to new users created from\n//     client signups.\n// - forbidClientAccountCreation {Boolean}\n//     Do not allow clients to create accounts directly.\n// - restrictCreationByEmailDomain {Function or String}\n//     Require created users to have an email matching the function or\n//     having the string as domain.\n// - loginExpirationInDays {Number}\n//     Number of days since login until a user is logged out (login token\n//     expires).\n//\nAccounts.config = function(options) {\n  // We don't want users to accidentally only call Accounts.config on the\n  // client, where some of the options will have partial effects (eg removing\n  // the \"create account\" button from accounts-ui if forbidClientAccountCreation\n  // is set, or redirecting Google login to a specific-domain page) without\n  // having their full effects.\n  if (Meteor.isServer) {\n    __meteor_runtime_config__.accountsConfigCalled = true;\n  } else if (!__meteor_runtime_config__.accountsConfigCalled) {\n    // XXX would be nice to \"crash\" the client and replace the UI with an error\n    // message, but there's no trivial way to do this.\n    Meteor._debug(\"Accounts.config was called on the client but not on the \" +\n                  \"server; some configuration options may not take effect.\");\n  }\n\n  // validate option keys\n  var VALID_KEYS = [\"sendVerificationEmail\", \"forbidClientAccountCreation\",\n                    \"restrictCreationByEmailDomain\", \"loginExpirationInDays\"];\n  _.each(_.keys(options), function (key) {\n    if (!_.contains(VALID_KEYS, key)) {\n      throw new Error(\"Accounts.config: Invalid key: \" + key);\n    }\n  });\n\n  // set values in Accounts._options\n  _.each(VALID_KEYS, function (key) {\n    if (key in options) {\n      if (key in Accounts._options) {\n        throw new Error(\"Can't set `\" + key + \"` more than once\");\n      } else {\n        Accounts._options[key] = options[key];\n      }\n    }\n  });\n\n  // If the user set loginExpirationInDays to null, then we need to clear the\n  // timer that periodically expires tokens.\n  if (Meteor.isServer)\n    maybeStopExpireTokensInterval();\n};\n\n// Users table. Don't use the normal autopublish, since we want to hide\n// some fields. Code to autopublish this is in accounts_server.js.\n// XXX Allow users to configure this collection name.\n//\nMeteor.users = new Meteor.Collection(\"users\", {_preventAutopublish: true});\n// There is an allow call in accounts_server that restricts this\n// collection.\n\n// loginServiceConfiguration and ConfigError are maintained for backwards compatibility\nAccounts.loginServiceConfiguration = ServiceConfiguration.configurations;\nAccounts.ConfigError = ServiceConfiguration.ConfigError;\n\n// Thrown when the user cancels the login process (eg, closes an oauth\n// popup, declines retina scan, etc)\nAccounts.LoginCancelledError = function(description) {\n  this.message = description;\n};\n\n// This is used to transmit specific subclass errors over the wire. We should\n// come up with a more generic way to do this (eg, with some sort of symbolic\n// error code rather than a number).\nAccounts.LoginCancelledError.numericError = 0x8acdc2f;\nAccounts.LoginCancelledError.prototype = new Error();\nAccounts.LoginCancelledError.prototype.name = 'Accounts.LoginCancelledError';\n\ngetTokenLifetimeMs = function () {\n  return (Accounts._options.loginExpirationInDays ||\n          DEFAULT_LOGIN_EXPIRATION_DAYS) * 24 * 60 * 60 * 1000;\n};\n\nAccounts._tokenExpiration = function (when) {\n  // We pass when through the Date constructor for backwards compatibility;\n  // `when` used to be a number.\n  return new Date((new Date(when)).getTime() + getTokenLifetimeMs());\n};\n\nAccounts._tokenExpiresSoon = function (when) {\n  var minLifetimeMs = .1 * getTokenLifetimeMs();\n  var minLifetimeCapMs = MIN_TOKEN_LIFETIME_CAP_SECS * 1000;\n  if (minLifetimeMs > minLifetimeCapMs)\n    minLifetimeMs = minLifetimeCapMs;\n  return new Date() > (new Date(when) - minLifetimeMs);\n};\n","///\n/// CURRENT USER\n///\n\nMeteor.userId = function () {\n  // This function only works if called inside a method. In theory, it\n  // could also be called from publish statements, since they also\n  // have a userId associated with them. However, given that publish\n  // functions aren't reactive, using any of the infomation from\n  // Meteor.user() in a publish function will always use the value\n  // from when the function first runs. This is likely not what the\n  // user expects. The way to make this work in a publish is to do\n  // Meteor.find(this.userId()).observe and recompute when the user\n  // record changes.\n  var currentInvocation = DDP._CurrentInvocation.get();\n  if (!currentInvocation)\n    throw new Error(\"Meteor.userId can only be invoked in method calls. Use this.userId in publish functions.\");\n  return currentInvocation.userId;\n};\n\nMeteor.user = function () {\n  var userId = Meteor.userId();\n  if (!userId)\n    return null;\n  return Meteor.users.findOne(userId);\n};\n\n///\n/// LOGIN HANDLERS\n///\n\n// The main entry point for auth packages to hook in to login.\n//\n// @param handler {Function} A function that receives an options object\n// (as passed as an argument to the `login` method) and returns one of:\n// - `undefined`, meaning don't handle;\n// - {id: userId, token: *, tokenExpires: *}, if the user logged in\n//   successfully. tokenExpires is optional and intends to provide a hint to the\n//   client as to when the token will expire. If not provided, the client will\n//   call Accounts._tokenExpiration, passing it the date that it received the\n//   token.\n// - throw an error, if the user failed to log in.\n//\nAccounts.registerLoginHandler = function(handler) {\n  loginHandlers.push(handler);\n};\n\n// list of all registered handlers.\nloginHandlers = [];\n\n\n// Try all of the registered login handlers until one of them doesn'\n// return `undefined`, meaning it handled this call to `login`. Return\n// that return value, which ought to be a {id/token} pair.\nvar tryAllLoginHandlers = function (options) {\n  for (var i = 0; i < loginHandlers.length; ++i) {\n    var handler = loginHandlers[i];\n    var result = handler(options);\n    if (result !== undefined)\n      return result;\n  }\n\n  throw new Meteor.Error(400, \"Unrecognized options for login request\");\n};\n\n\n// Actual methods for login and logout. This is the entry point for\n// clients to actually log in.\nMeteor.methods({\n  // @returns {Object|null}\n  //   If successful, returns {token: reconnectToken, id: userId}\n  //   If unsuccessful (for example, if the user closed the oauth login popup),\n  //     returns null\n  login: function(options) {\n    // Login handlers should really also check whatever field they look at in\n    // options, but we don't enforce it.\n    check(options, Object);\n    var result = tryAllLoginHandlers(options);\n    if (result !== null) {\n      this.setUserId(result.id);\n      Accounts._setLoginToken(this.connection.id, result.token);\n    }\n    return result;\n  },\n\n  logout: function() {\n    var token = Accounts._getLoginToken(this.connection.id);\n    Accounts._setLoginToken(this.connection.id, null);\n    if (token && this.userId)\n      removeLoginToken(this.userId, token);\n    this.setUserId(null);\n  },\n\n  // Delete all the current user's tokens and close all open connections logged\n  // in as this user. Returns a fresh new login token that this client can\n  // use. Tests set Accounts._noConnectionCloseDelayForTest to delete tokens\n  // immediately instead of using a delay.\n  //\n  // @returns {Object} Object with token and tokenExpires keys.\n  logoutOtherClients: function () {\n    var self = this;\n    var user = Meteor.users.findOne(self.userId, {\n      fields: {\n        \"services.resume.loginTokens\": true\n      }\n    });\n    if (user) {\n      // Save the current tokens in the database to be deleted in\n      // CONNECTION_CLOSE_DELAY_MS ms. This gives other connections in the\n      // caller's browser time to find the fresh token in localStorage. We save\n      // the tokens in the database in case we crash before actually deleting\n      // them.\n      var tokens = user.services.resume.loginTokens;\n      var newToken = Accounts._generateStampedLoginToken();\n      var userId = self.userId;\n      Meteor.users.update(self.userId, {\n        $set: {\n          \"services.resume.loginTokensToDelete\": tokens,\n          \"services.resume.haveLoginTokensToDelete\": true\n        },\n        $push: { \"services.resume.loginTokens\": newToken }\n      });\n      Meteor.setTimeout(function () {\n        // The observe on Meteor.users will take care of closing the connections\n        // associated with `tokens`.\n        deleteSavedTokens(userId, tokens);\n      }, Accounts._noConnectionCloseDelayForTest ? 0 :\n                        CONNECTION_CLOSE_DELAY_MS);\n      // We do not set the login token on this connection, but instead the\n      // observe closes the connection and the client will reconnect with the\n      // new token.\n      return {\n        token: newToken.token,\n        tokenExpires: Accounts._tokenExpiration(newToken.when)\n      };\n    } else {\n      throw new Error(\"You are not logged in.\");\n    }\n  }\n});\n\n///\n/// ACCOUNT DATA\n///\n\n// connectionId -> {connection, loginToken, srpChallenge}\nvar accountData = {};\n\nAccounts._getAccountData = function (connectionId, field) {\n  var data = accountData[connectionId];\n  return data && data[field];\n};\n\nAccounts._setAccountData = function (connectionId, field, value) {\n  var data = accountData[connectionId];\n\n  // safety belt. shouldn't happen. accountData is set in onConnection,\n  // we don't have a connectionId until it is set.\n  if (!data)\n    return;\n\n  if (value === undefined)\n    delete data[field];\n  else\n    data[field] = value;\n};\n\nMeteor.server.onConnection(function (connection) {\n  accountData[connection.id] = {connection: connection};\n  connection.onClose(function () {\n    removeConnectionFromToken(connection.id);\n    delete accountData[connection.id];\n  });\n});\n\n\n///\n/// RECONNECT TOKENS\n///\n/// support reconnecting using a meteor login token\n\n// token -> list of connection ids\nvar connectionsByLoginToken = {};\n\n// test hook\nAccounts._getTokenConnections = function (token) {\n  return connectionsByLoginToken[token];\n};\n\n// Remove the connection from the list of open connections for the token.\nvar removeConnectionFromToken = function (connectionId) {\n  var token = Accounts._getLoginToken(connectionId);\n  if (token) {\n    connectionsByLoginToken[token] = _.without(\n      connectionsByLoginToken[token],\n      connectionId\n    );\n    if (_.isEmpty(connectionsByLoginToken[token]))\n      delete connectionsByLoginToken[token];\n  }\n};\n\nAccounts._getLoginToken = function (connectionId) {\n  return Accounts._getAccountData(connectionId, 'loginToken');\n};\n\nAccounts._setLoginToken = function (connectionId, newToken) {\n  removeConnectionFromToken(connectionId);\n\n  Accounts._setAccountData(connectionId, 'loginToken', newToken);\n\n  if (newToken) {\n    if (! _.has(connectionsByLoginToken, newToken))\n      connectionsByLoginToken[newToken] = [];\n    connectionsByLoginToken[newToken].push(connectionId);\n  }\n};\n\n// Close all open connections associated with any of the tokens in\n// `tokens`.\nvar closeConnectionsForTokens = function (tokens) {\n  _.each(tokens, function (token) {\n    if (_.has(connectionsByLoginToken, token)) {\n      // safety belt. close should defer potentially yielding callbacks.\n      Meteor._noYieldsAllowed(function () {\n        _.each(connectionsByLoginToken[token], function (connectionId) {\n          var connection = Accounts._getAccountData(connectionId, 'connection');\n          if (connection)\n            connection.close();\n        });\n      });\n    }\n  });\n};\n\n\n// Login handler for resume tokens.\nAccounts.registerLoginHandler(function(options) {\n  if (!options.resume)\n    return undefined;\n\n  check(options.resume, String);\n  var user = Meteor.users.findOne({\n    \"services.resume.loginTokens.token\": \"\"+options.resume\n  });\n\n  if (!user) {\n    throw new Meteor.Error(403, \"You've been logged out by the server. \" +\n    \"Please login again.\");\n  }\n\n  var token = _.find(user.services.resume.loginTokens, function (token) {\n    return token.token === options.resume;\n  });\n\n  var tokenExpires = Accounts._tokenExpiration(token.when);\n  if (new Date() >= tokenExpires)\n    throw new Meteor.Error(403, \"Your session has expired. Please login again.\");\n\n  return {\n    token: options.resume,\n    tokenExpires: tokenExpires,\n    id: user._id\n  };\n});\n\n// Semi-public. Used by other login methods to generate tokens.\n//\nAccounts._generateStampedLoginToken = function () {\n  return {token: Random.id(), when: (new Date)};\n};\n\n// Deletes the given loginToken from the database. This will cause all\n// connections associated with the token to be closed.\nvar removeLoginToken = function (userId, loginToken) {\n  Meteor.users.update(userId, {\n    $pull: {\n      \"services.resume.loginTokens\": { \"token\": loginToken }\n    }\n  });\n};\n\n///\n/// TOKEN EXPIRATION\n///\n\nvar expireTokenInterval;\n\n// Deletes expired tokens from the database and closes all open connections\n// associated with these tokens.\n//\n// Exported for tests. Also, the arguments are only used by\n// tests. oldestValidDate is simulate expiring tokens without waiting\n// for them to actually expire. userId is used by tests to only expire\n// tokens for the test user.\nvar expireTokens = Accounts._expireTokens = function (oldestValidDate, userId) {\n  var tokenLifetimeMs = getTokenLifetimeMs();\n\n  // when calling from a test with extra arguments, you must specify both!\n  if ((oldestValidDate && !userId) || (!oldestValidDate && userId)) {\n    throw new Error(\"Bad test. Must specify both oldestValidDate and userId.\");\n  }\n\n  oldestValidDate = oldestValidDate ||\n    (new Date(new Date() - tokenLifetimeMs));\n  var userFilter = userId ? {_id: userId} : {};\n\n\n  // Backwards compatible with older versions of meteor that stored login token\n  // timestamps as numbers.\n  Meteor.users.update(_.extend(userFilter, {\n    $or: [\n      { \"services.resume.loginTokens.when\": { $lt: oldestValidDate } },\n      { \"services.resume.loginTokens.when\": { $lt: +oldestValidDate } }\n    ]\n  }), {\n    $pull: {\n      \"services.resume.loginTokens\": {\n        $or: [\n          { when: { $lt: oldestValidDate } },\n          { when: { $lt: +oldestValidDate } }\n        ]\n      }\n    }\n  }, { multi: true });\n  // The observe on Meteor.users will take care of closing connections for\n  // expired tokens.\n};\n\nmaybeStopExpireTokensInterval = function () {\n  if (_.has(Accounts._options, \"loginExpirationInDays\") &&\n      Accounts._options.loginExpirationInDays === null &&\n      expireTokenInterval) {\n    Meteor.clearInterval(expireTokenInterval);\n    expireTokenInterval = null;\n  }\n};\n\nexpireTokenInterval = Meteor.setInterval(expireTokens,\n                                         EXPIRE_TOKENS_INTERVAL_MS);\n\n///\n/// CREATE USER HOOKS\n///\n\nvar onCreateUserHook = null;\nAccounts.onCreateUser = function (func) {\n  if (onCreateUserHook)\n    throw new Error(\"Can only call onCreateUser once\");\n  else\n    onCreateUserHook = func;\n};\n\n// XXX see comment on Accounts.createUser in passwords_server about adding a\n// second \"server options\" argument.\nvar defaultCreateUserHook = function (options, user) {\n  if (options.profile)\n    user.profile = options.profile;\n  return user;\n};\n\n// Called by accounts-password\nAccounts.insertUserDoc = function (options, user) {\n  // - clone user document, to protect from modification\n  // - add createdAt timestamp\n  // - prepare an _id, so that you can modify other collections (eg\n  // create a first task for every new user)\n  //\n  // XXX If the onCreateUser or validateNewUser hooks fail, we might\n  // end up having modified some other collection\n  // inappropriately. The solution is probably to have onCreateUser\n  // accept two callbacks - one that gets called before inserting\n  // the user document (in which you can modify its contents), and\n  // one that gets called after (in which you should change other\n  // collections)\n  user = _.extend({createdAt: new Date(), _id: Random.id()}, user);\n\n  var result = {};\n  if (options.generateLoginToken) {\n    var stampedToken = Accounts._generateStampedLoginToken();\n    result.token = stampedToken.token;\n    result.tokenExpires = Accounts._tokenExpiration(stampedToken.when);\n    Meteor._ensure(user, 'services', 'resume');\n    if (_.has(user.services.resume, 'loginTokens'))\n      user.services.resume.loginTokens.push(stampedToken);\n    else\n      user.services.resume.loginTokens = [stampedToken];\n  }\n\n  var fullUser;\n  if (onCreateUserHook) {\n    fullUser = onCreateUserHook(options, user);\n\n    // This is *not* part of the API. We need this because we can't isolate\n    // the global server environment between tests, meaning we can't test\n    // both having a create user hook set and not having one set.\n    if (fullUser === 'TEST DEFAULT HOOK')\n      fullUser = defaultCreateUserHook(options, user);\n  } else {\n    fullUser = defaultCreateUserHook(options, user);\n  }\n\n  _.each(validateNewUserHooks, function (hook) {\n    if (!hook(fullUser))\n      throw new Meteor.Error(403, \"User validation failed\");\n  });\n\n  try {\n    result.id = Meteor.users.insert(fullUser);\n  } catch (e) {\n    // XXX string parsing sucks, maybe\n    // https://jira.mongodb.org/browse/SERVER-3069 will get fixed one day\n    if (e.name !== 'MongoError') throw e;\n    var match = e.err.match(/^E11000 duplicate key error index: ([^ ]+)/);\n    if (!match) throw e;\n    if (match[1].indexOf('$emails.address') !== -1)\n      throw new Meteor.Error(403, \"Email already exists.\");\n    if (match[1].indexOf('username') !== -1)\n      throw new Meteor.Error(403, \"Username already exists.\");\n    // XXX better error reporting for services.facebook.id duplicate, etc\n    throw e;\n  }\n\n  return result;\n};\n\nvar validateNewUserHooks = [];\nAccounts.validateNewUser = function (func) {\n  validateNewUserHooks.push(func);\n};\n\n// XXX Find a better place for this utility function\n// Like Perl's quotemeta: quotes all regexp metacharacters. See\n//   https://github.com/substack/quotemeta/blob/master/index.js\nvar quotemeta = function (str) {\n    return String(str).replace(/(\\W)/g, '\\\\$1');\n};\n\n// Helper function: returns false if email does not match company domain from\n// the configuration.\nvar testEmailDomain = function (email) {\n  var domain = Accounts._options.restrictCreationByEmailDomain;\n  return !domain ||\n    (_.isFunction(domain) && domain(email)) ||\n    (_.isString(domain) &&\n      (new RegExp('@' + quotemeta(domain) + '$', 'i')).test(email));\n};\n\n// Validate new user's email or Google/Facebook/GitHub account's email\nAccounts.validateNewUser(function (user) {\n  var domain = Accounts._options.restrictCreationByEmailDomain;\n  if (!domain)\n    return true;\n\n  var emailIsGood = false;\n  if (!_.isEmpty(user.emails)) {\n    emailIsGood = _.any(user.emails, function (email) {\n      return testEmailDomain(email.address);\n    });\n  } else if (!_.isEmpty(user.services)) {\n    // Find any email of any service and check it\n    emailIsGood = _.any(user.services, function (service) {\n      return service.email && testEmailDomain(service.email);\n    });\n  }\n\n  if (emailIsGood)\n    return true;\n\n  if (_.isString(domain))\n    throw new Meteor.Error(403, \"@\" + domain + \" email required\");\n  else\n    throw new Meteor.Error(403, \"Email doesn't match the criteria.\");\n});\n\n///\n/// MANAGING USER OBJECTS\n///\n\n// Updates or creates a user after we authenticate with a 3rd party.\n//\n// @param serviceName {String} Service name (eg, twitter).\n// @param serviceData {Object} Data to store in the user's record\n//        under services[serviceName]. Must include an \"id\" field\n//        which is a unique identifier for the user in the service.\n// @param options {Object, optional} Other options to pass to insertUserDoc\n//        (eg, profile)\n// @returns {Object} Object with token and id keys, like the result\n//        of the \"login\" method.\n//\nAccounts.updateOrCreateUserFromExternalService = function(\n  serviceName, serviceData, options) {\n  options = _.clone(options || {});\n\n  if (serviceName === \"password\" || serviceName === \"resume\")\n    throw new Error(\n      \"Can't use updateOrCreateUserFromExternalService with internal service \"\n        + serviceName);\n  if (!_.has(serviceData, 'id'))\n    throw new Error(\n      \"Service data for service \" + serviceName + \" must include id\");\n\n  // Look for a user with the appropriate service user id.\n  var selector = {};\n  var serviceIdKey = \"services.\" + serviceName + \".id\";\n\n  // XXX Temporary special case for Twitter. (Issue #629)\n  //   The serviceData.id will be a string representation of an integer.\n  //   We want it to match either a stored string or int representation.\n  //   This is to cater to earlier versions of Meteor storing twitter\n  //   user IDs in number form, and recent versions storing them as strings.\n  //   This can be removed once migration technology is in place, and twitter\n  //   users stored with integer IDs have been migrated to string IDs.\n  if (serviceName === \"twitter\" && !isNaN(serviceData.id)) {\n    selector[\"$or\"] = [{},{}];\n    selector[\"$or\"][0][serviceIdKey] = serviceData.id;\n    selector[\"$or\"][1][serviceIdKey] = parseInt(serviceData.id, 10);\n  } else {\n    selector[serviceIdKey] = serviceData.id;\n  }\n\n  var user = Meteor.users.findOne(selector);\n\n  if (user) {\n    // We *don't* process options (eg, profile) for update, but we do replace\n    // the serviceData (eg, so that we keep an unexpired access token and\n    // don't cache old email addresses in serviceData.email).\n    // XXX provide an onUpdateUser hook which would let apps update\n    //     the profile too\n    var stampedToken = Accounts._generateStampedLoginToken();\n    var setAttrs = {};\n    _.each(serviceData, function(value, key) {\n      setAttrs[\"services.\" + serviceName + \".\" + key] = value;\n    });\n\n    // XXX Maybe we should re-use the selector above and notice if the update\n    //     touches nothing?\n    Meteor.users.update(\n      user._id,\n      {$set: setAttrs,\n       $push: {'services.resume.loginTokens': stampedToken}});\n    return {\n      token: stampedToken.token,\n      id: user._id,\n      tokenExpires: Accounts._tokenExpiration(stampedToken.when)\n    };\n  } else {\n    // Create a new user with the service data. Pass other options through to\n    // insertUserDoc.\n    user = {services: {}};\n    user.services[serviceName] = serviceData;\n    options.generateLoginToken = true;\n    return Accounts.insertUserDoc(options, user);\n  }\n};\n\n\n///\n/// PUBLISHING DATA\n///\n\n// Publish the current user's record to the client.\nMeteor.publish(null, function() {\n  if (this.userId) {\n    return Meteor.users.find(\n      {_id: this.userId},\n      {fields: {profile: 1, username: 1, emails: 1}});\n  } else {\n    return null;\n  }\n}, /*suppress autopublish warning*/{is_auto: true});\n\n// If autopublish is on, publish these user fields. Login service\n// packages (eg accounts-google) add to these by calling\n// Accounts.addAutopublishFields Notably, this isn't implemented with\n// multiple publishes since DDP only merges only across top-level\n// fields, not subfields (such as 'services.facebook.accessToken')\nvar autopublishFields = {\n  loggedInUser: ['profile', 'username', 'emails'],\n  otherUsers: ['profile', 'username']\n};\n\n// Add to the list of fields or subfields to be automatically\n// published if autopublish is on. Must be called from top-level\n// code (ie, before Meteor.startup hooks run).\n//\n// @param opts {Object} with:\n//   - forLoggedInUser {Array} Array of fields published to the logged-in user\n//   - forOtherUsers {Array} Array of fields published to users that aren't logged in\nAccounts.addAutopublishFields = function(opts) {\n  autopublishFields.loggedInUser.push.apply(\n    autopublishFields.loggedInUser, opts.forLoggedInUser);\n  autopublishFields.otherUsers.push.apply(\n    autopublishFields.otherUsers, opts.forOtherUsers);\n};\n\nif (Package.autopublish) {\n  // Use Meteor.startup to give other packages a chance to call\n  // addAutopublishFields.\n  Meteor.startup(function () {\n    // ['profile', 'username'] -> {profile: 1, username: 1}\n    var toFieldSelector = function(fields) {\n      return _.object(_.map(fields, function(field) {\n        return [field, 1];\n      }));\n    };\n\n    Meteor.server.publish(null, function () {\n      if (this.userId) {\n        return Meteor.users.find(\n          {_id: this.userId},\n          {fields: toFieldSelector(autopublishFields.loggedInUser)});\n      } else {\n        return null;\n      }\n    }, /*suppress autopublish warning*/{is_auto: true});\n\n    // XXX this publish is neither dedup-able nor is it optimized by our special\n    // treatment of queries on a specific _id. Therefore this will have O(n^2)\n    // run-time performance every time a user document is changed (eg someone\n    // logging in). If this is a problem, we can instead write a manual publish\n    // function which filters out fields based on 'this.userId'.\n    Meteor.server.publish(null, function () {\n      var selector;\n      if (this.userId)\n        selector = {_id: {$ne: this.userId}};\n      else\n        selector = {};\n\n      return Meteor.users.find(\n        selector,\n        {fields: toFieldSelector(autopublishFields.otherUsers)});\n    }, /*suppress autopublish warning*/{is_auto: true});\n  });\n}\n\n// Publish all login service configuration fields other than secret.\nMeteor.publish(\"meteor.loginServiceConfiguration\", function () {\n  return ServiceConfiguration.configurations.find({}, {fields: {secret: 0}});\n}, {is_auto: true}); // not techincally autopublish, but stops the warning.\n\n// Allow a one-time configuration for a login service. Modifications\n// to this collection are also allowed in insecure mode.\nMeteor.methods({\n  \"configureLoginService\": function (options) {\n    check(options, Match.ObjectIncluding({service: String}));\n    // Don't let random users configure a service we haven't added yet (so\n    // that when we do later add it, it's set up with their configuration\n    // instead of ours).\n    // XXX if service configuration is oauth-specific then this code should\n    //     be in accounts-oauth; if it's not then the registry should be\n    //     in this package\n    if (!(Accounts.oauth\n          && _.contains(Accounts.oauth.serviceNames(), options.service))) {\n      throw new Meteor.Error(403, \"Service unknown\");\n    }\n    if (ServiceConfiguration.configurations.findOne({service: options.service}))\n      throw new Meteor.Error(403, \"Service \" + options.service + \" already configured\");\n    ServiceConfiguration.configurations.insert(options);\n  }\n});\n\n\n///\n/// RESTRICTING WRITES TO USER OBJECTS\n///\n\nMeteor.users.allow({\n  // clients can modify the profile field of their own document, and\n  // nothing else.\n  update: function (userId, user, fields, modifier) {\n    // make sure it is our record\n    if (user._id !== userId)\n      return false;\n\n    // user can only modify the 'profile' field. sets to multiple\n    // sub-keys (eg profile.foo and profile.bar) are merged into entry\n    // in the fields list.\n    if (fields.length !== 1 || fields[0] !== 'profile')\n      return false;\n\n    return true;\n  },\n  fetch: ['_id'] // we only look at _id.\n});\n\n/// DEFAULT INDEXES ON USERS\nMeteor.users._ensureIndex('username', {unique: 1, sparse: 1});\nMeteor.users._ensureIndex('emails.address', {unique: 1, sparse: 1});\nMeteor.users._ensureIndex('services.resume.loginTokens.token',\n                          {unique: 1, sparse: 1});\n// For taking care of logoutOtherClients calls that crashed before the tokens\n// were deleted.\nMeteor.users._ensureIndex('services.resume.haveLoginTokensToDelete',\n                          { sparse: 1 });\n// For expiring login tokens\nMeteor.users._ensureIndex(\"services.resume.loginTokens.when\", { sparse: 1 });\n\n///\n/// CLEAN UP FOR `logoutOtherClients`\n///\n\nvar deleteSavedTokens = function (userId, tokensToDelete) {\n  if (tokensToDelete) {\n    Meteor.users.update(userId, {\n      $unset: {\n        \"services.resume.haveLoginTokensToDelete\": 1,\n        \"services.resume.loginTokensToDelete\": 1\n      },\n      $pullAll: {\n        \"services.resume.loginTokens\": tokensToDelete\n      }\n    });\n  }\n};\n\nMeteor.startup(function () {\n  // If we find users who have saved tokens to delete on startup, delete them\n  // now. It's possible that the server could have crashed and come back up\n  // before new tokens are found in localStorage, but this shouldn't happen very\n  // often. We shouldn't put a delay here because that would give a lot of power\n  // to an attacker with a stolen login token and the ability to crash the\n  // server.\n  var users = Meteor.users.find({\n    \"services.resume.haveLoginTokensToDelete\": true\n  }, {\n    \"services.resume.loginTokensToDelete\": 1\n  });\n  users.forEach(function (user) {\n    deleteSavedTokens(user._id, user.services.resume.loginTokensToDelete);\n  });\n});\n\n///\n/// LOGGING OUT DELETED USERS\n///\n\nvar closeTokensForUser = function (userTokens) {\n  closeConnectionsForTokens(_.pluck(userTokens, \"token\"));\n};\n\n// Like _.difference, but uses EJSON.equals to compute which values to return.\nvar differenceObj = function (array1, array2) {\n  return _.filter(array1, function (array1Value) {\n    return ! _.some(array2, function (array2Value) {\n      return EJSON.equals(array1Value, array2Value);\n    });\n  });\n};\n\nMeteor.users.find({}, { fields: { \"services.resume\": 1 }}).observe({\n  changed: function (newUser, oldUser) {\n    var removedTokens = [];\n    if (newUser.services && newUser.services.resume &&\n        oldUser.services && oldUser.services.resume) {\n      removedTokens = differenceObj(oldUser.services.resume.loginTokens || [],\n                                    newUser.services.resume.loginTokens || []);\n    } else if (oldUser.services && oldUser.services.resume) {\n      removedTokens = oldUser.services.resume.loginTokens || [];\n    }\n    closeTokensForUser(removedTokens);\n  },\n  removed: function (oldUser) {\n    if (oldUser.services && oldUser.services.resume)\n      closeTokensForUser(oldUser.services.resume.loginTokens || []);\n  }\n});\n","// XXX These should probably not actually be public?\n\nAccounts.urls = {};\n\nAccounts.urls.resetPassword = function (token) {\n  return Meteor.absoluteUrl('#/reset-password/' + token);\n};\n\nAccounts.urls.verifyEmail = function (token) {\n  return Meteor.absoluteUrl('#/verify-email/' + token);\n};\n\nAccounts.urls.enrollAccount = function (token) {\n  return Meteor.absoluteUrl('#/enroll-account/' + token);\n};\n"]}