{"version":3,"file":"/packages/collection-hooks.js","sources":["collection-hooks/collection-hooks.js","collection-hooks/insert.js","collection-hooks/update.js","collection-hooks/remove.js","collection-hooks/find.js","collection-hooks/findone.js","collection-hooks/users-compat.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA,4B;AACA,kD;AACA,mE;AACA,yB;;AAEA,iB;AACA,kB;AACA,oC;;AAEA,sB;AACA,a;;AAEA,wB;AACA,kC;AACA,gD;AACA,O;AACA,G;;AAEA,wB;AACA,S;AACA,uD;AACA,mD;AACA,gD;AACA,kB;;AAEA,kB;AACA,+B;AACA,K;AACA,G;;AAEA,gB;AACA,C;;AAEA,qB;;AAEA,4D;AACA,2D;AACA,6C;AACA,mD;AACA,+C;AACA,6C;AACA,+C;;AAEA,2C;AACA,kD;AACA,+D;AACA,gB;AACA,sC;AACA,uE;AACA,Y;AACA,+B;AACA,+D;AACA,W;AACA,U;AACA,Q;AACA,O;AACA,K;;AAEA,iE;AACA,6C;AACA,2E;;AAEA,uE;AACA,8B;AACA,oB;AACA,e;AACA,oC;AACA,wB;AACA,+C;AACA,sE;AACA,sD;AACA,U;AACA,4B;AACA,Q;AACA,M;AACA,K;AACA,E;;AAEA,0D;AACA,2B;AACA,E;;AAEA,oE;AACA,kB;;AAEA,gF;;AAEA,I;AACA,qC;AACA,yC;AACA,4B;AACA,wD;AACA,wC;AACA,O;AACA,G;AACA,I;;AAEA,8E;AACA,gD;AACA,gB;AACA,4E;AACA,wE;AACA,6E;AACA,uC;AACA,yB;AACA,4B;AACA,K;AACA,G;;AAEA,6D;AACA,6B;AACA,gD;AACA,E;;AAEA,iC;AACA,+C;AACA,iD;AACA,a;AACA,E;;AAEA,mE;;AAEA,+B;AACA,yC;AACA,gD;AACA,G;AACA,C;;AAEA,sB;AACA,gC;AACA,0C;AACA,kD;AACA,0C;AACA,4C;AACA,gC;AACA,iB;AACA,O;AACA,I;AACA,C;;;;;;;;;;;;;;;;;;AC1IA,+F;AACA,kB;AACA,wD;AACA,yC;AACA,iB;;AAEA,kB;AACA,uB;;AAEA,W;AACA,4C;AACA,4F;AACA,kC;AACA,K;;AAEA,0B;;AAEA,2B;AACA,sB;AACA,a;AACA,iC;AACA,mB;AACA,K;AACA,gF;AACA,6C;AACA,qC;AACA,O;AACA,c;AACA,G;;AAEA,c;AACA,2D;AACA,qD;AACA,4C;AACA,O;AACA,U;AACA,mC;AACA,qD;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;ACvCA,+F;AACA,kB;AACA,wD;AACA,yC;AACA,qC;AACA,wE;;AAEA,uB;AACA,sB;AACA,iC;AACA,uB;;AAEA,8B;AACA,sB;AACA,iB;AACA,G;;AAEA,8B;AACA,kF;;AAEA,4D;AACA,sB;AACA,wC;AACA,wC;AACA,mB;AACA,iC;AACA,4C;AACA,O;AACA,G;;AAEA,W;AACA,4C;AACA,iC;AACA,gH;AACA,oC;AACA,O;AACA,K;;AAEA,0B;;AAEA,iC;AACA,oC;AACA,wF;;AAEA,6C;AACA,mC;AACA,8B;AACA,uC;AACA,uC;AACA,6B;AACA,kB;AACA,kE;AACA,S;AACA,O;AACA,G;;AAEA,c;AACA,kF;AACA,2B;AACA,4C;AACA,O;AACA,U;AACA,4C;AACA,oB;AACA,oB;AACA,G;AACA,G;;AAEA,qE;AACA,0D;AACA,6E;AACA,0B;AACA,oC;AACA,4B;AACA,kB;AACA,yC;AACA,6C;AACA,2D;AACA,uB;AACA,oC;AACA,uD;;AAEA,iD;AACA,qC;AACA,2B;AACA,O;AACA,K;;AAEA,gB;AACA,E;;AAEA,qE;AACA,kD;AACA,6E;AACA,0B;AACA,oC;AACA,4B;AACA,kB;;AAEA,yC;AACA,4C;AACA,2H;AACA,4C;AACA,+C;AACA,6D;AACA,yB;AACA,sC;AACA,yD;;AAEA,mD;AACA,uC;AACA,6B;AACA,S;AACA,4C;AACA,Y;AACA,sB;AACA,K;AACA,4C;AACA,K;;AAEA,gB;AACA,E;;;;;;;;;;;;;;;;;;ACzHA,+F;AACA,kB;AACA,wD;AACA,yC;AACA,6B;AACA,wE;;AAEA,uB;AACA,uB;;AAEA,6E;;AAEA,4D;AACA,sB;AACA,iC;AACA,kC;AACA,O;AACA,G;;AAEA,W;AACA,4C;AACA,iC;AACA,sF;AACA,oC;AACA,O;AACA,K;;AAEA,0B;;AAEA,uB;AACA,6C;AACA,mC;AACA,0F;AACA,S;AACA,O;AACA,G;;AAEA,c;AACA,sD;AACA,iB;AACA,4C;AACA,O;AACA,U;AACA,0C;AACA,Y;AACA,kB;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;AC/CA,6F;AACA,kB;AACA,wD;AACA,iB;;AAEA,uB;AACA,sB;;AAEA,W;AACA,4C;AACA,uD;AACA,kC;AACA,K;;AAEA,0B;;AAEA,0B;AACA,6C;AACA,yD;AACA,O;AACA,G;;AAEA,iC;AACA,a;;AAEA,a;AACA,G;;;;;;;;;;;;;;;;;;AC1BA,gG;AACA,kB;AACA,wD;AACA,iB;;AAEA,uB;AACA,sB;;AAEA,W;AACA,4C;AACA,uD;AACA,kC;AACA,K;;AAEA,0B;;AAEA,uB;AACA,6C;AACA,sD;AACA,O;AACA,G;;AAEA,iC;AACA,a;;AAEA,a;AACA,G;;;;;;;;;;;;;;;;;;AC1BA,mB;AACA,yD;AACA,C","sourcesContent":["// Relevant AOP terminology:\n// Aspect: User code that runs before/after (hook)\n// Advice: Wrapper code that knows when to call user code (aspects)\n// Pointcut: before/after\n\nvar advices = {};\nvar currentUserId;\nvar constructor = Meteor.Collection;\n\nfunction getUserId() {\n  var userId;\n\n  if (Meteor.isClient) {\n    Deps.nonreactive(function () {\n      userId = Meteor.userId && Meteor.userId();\n    });\n  }\n\n  if (Meteor.isServer) {\n    try {\n      // Will throw an error unless within method call.\n      // Attempt to recover gracefully by catching:\n      userId = Meteor.userId && Meteor.userId();\n    } catch (e) {}\n\n    if (!userId) {\n        userId = currentUserId;\n    }\n  }\n\n  return userId;\n}\n\nCollectionHooks = {};\n\nCollectionHooks.extendCollectionInstance = function (self) {\n  // Offer a public API to allow the user to define aspects\n  // Example: collection.before.insert(func);\n  _.each([\"before\", \"after\"], function (pointcut) {\n    _.each(advices, function (advice, method) {\n      Meteor._ensure(self, pointcut, method);\n      Meteor._ensure(self, \"_aspects\", method);\n\n      self._aspects[method][pointcut] = [];\n      self[pointcut][method] = function (aspect) {\n        var len = self._aspects[method][pointcut].push(aspect);\n        return {\n          replace: function (aspect) {\n            self._aspects[method][pointcut].splice(len - 1, 1, aspect);\n          },\n          remove: function () {\n            self._aspects[method][pointcut].splice(len - 1, 1);\n          }\n        };\n      };\n    });\n  });\n\n  // Wrap mutator methods, letting the defined advice do the work\n  _.each(advices, function (advice, method) {\n    var _super = Meteor.isClient ? self[method] : self._collection[method];\n\n    (Meteor.isClient ? self : self._collection)[method] = function () {\n      return advice.call(this,\n        getUserId(),\n        _super,\n        self._aspects[method] || {},\n        function (doc) {\n          return  _.isFunction(self._transform)\n                  ? function (d) { return self._transform(d || doc); }\n                  : function (d) { return d || doc; };\n        },\n        _.toArray(arguments)\n      );\n    };\n  });\n};\n\nCollectionHooks.defineAdvice = function (method, advice) {\n  advices[method] = advice;\n};\n\nCollectionHooks.getDocs = function (collection, selector, options) {\n  var self = this;\n\n  var findOptions = {transform: null, reactive: false}; // added reactive: false\n\n  /*\n  // No \"fetch\" support at this time.\n  if (!self._validators.fetchAllFields) {\n    findOptions.fields = {};\n    _.each(self._validators.fetch, function(fieldName) {\n      findOptions.fields[fieldName] = 1;\n    });\n  }\n  */\n\n  // Bit of a magic condition here... only \"update\" passes options, so this is\n  // only relevant to when update calls getDocs:\n  if (options) {\n    // This was added because in our case, we are potentially iterating over\n    // multiple docs. If multi isn't enabled, force a limit (almost like\n    // findOne), as the default for update without multi enabled is to affect\n    // only the first matched document:\n    if (!options.multi) {\n      findOptions.limit = 1;\n    }\n  }\n\n  // Unlike validators, we iterate over multiple docs, so use\n  // find instead of findOne:\n  return collection.find(selector, findOptions);\n};\n\nMeteor.Collection = function () {\n  var ret = constructor.apply(this, arguments);\n  CollectionHooks.extendCollectionInstance(this);\n  return ret;\n};\n\nMeteor.Collection.prototype = Object.create(constructor.prototype);\n\nfor (var func in constructor) {\n  if (constructor.hasOwnProperty(func)) {\n    Meteor.Collection[func] = constructor[func];\n  }\n}\n\nif (Meteor.isServer) {\n  var _publish = Meteor.publish;\n  Meteor.publish = function (name, func) {\n    return _publish.call(this, name, function () {\n      currentUserId = this && this.userId;\n      var ret = func.apply(this, arguments);\n      currentUserId = undefined;\n      return ret;\n    });\n  };\n}","CollectionHooks.defineAdvice(\"insert\", function (userId, _super, aspects, getTransform, args) {\n  var self = this;\n  var ctx = {context: self, _super: _super, args: args};\n  var async = _.isFunction(_.last(args));\n  var abort, ret;\n\n  // args[0] : doc\n  // args[1] : callback\n\n  // before\n  _.each(aspects.before, function (aspect) {\n    var r = aspect.call(_.extend({transform: getTransform(args[0])}, ctx), userId, args[0]);\n    if (r === false) abort = true;\n  });\n\n  if (abort) return false;\n\n  function after(id, err) {\n    var doc = args[0];\n    if (id) {\n      doc = EJSON.clone(args[0]);\n      doc._id = id;\n    }\n    var lctx = _.extend({transform: getTransform(doc), _id: id, err: err}, ctx);\n    _.each(aspects.after, function (aspect) {\n      aspect.call(lctx, userId, doc);\n    });\n    return id;\n  }\n\n  if (async) {\n    return _super.call(self, args[0], function (err, obj) {\n      after(obj && obj[0] && obj[0]._id || obj, err);\n      return args[1].apply(this, arguments);\n    });\n  } else {\n    ret = _super.apply(self, args);\n    return after(ret && ret[0] && ret[0]._id || ret);\n  }\n});","CollectionHooks.defineAdvice(\"update\", function (userId, _super, aspects, getTransform, args) {\n  var self = this;\n  var ctx = {context: self, _super: _super, args: args};\n  var async = _.isFunction(_.last(args));\n  var docs, fields, abort, prev = {};\n  var collection = _.has(self, \"_collection\") ? self._collection : self;\n\n  // args[0] : selector\n  // args[1] : mutator\n  // args[2] : options (optional)\n  // args[3] : callback\n\n  if (_.isFunction(args[2])) {\n    args[3] = args[2];\n    args[2] = {};\n  }\n\n  fields = getFields(args[1]);\n  docs = CollectionHooks.getDocs.call(self, collection, args[0], args[2]).fetch();\n\n  // copy originals for convenience for the \"after\" pointcut\n  if (aspects.after) {\n    prev.mutator = EJSON.clone(args[1]);\n    prev.options = EJSON.clone(args[2]);\n    prev.docs = {};\n    _.each(docs, function (doc) {\n      prev.docs[doc._id] = EJSON.clone(doc);\n    });\n  }\n\n  // before\n  _.each(aspects.before, function (aspect) {\n    _.each(docs, function (doc) {\n      var r = aspect.call(_.extend({transform: getTransform(doc)}, ctx), userId, doc, fields, args[1], args[2]);\n      if (r === false) abort = true;\n    });\n  });\n\n  if (abort) return false;\n\n  function after(affected, err) {\n    var fields = getFields(args[1]);\n    var docs = CollectionHooks.getDocs.call(self, collection, args[0], args[2]).fetch();\n\n    _.each(aspects.after, function (aspect) {\n      _.each(docs, function (doc) {\n        aspect.call(_.extend({\n          transform: getTransform(doc),\n          previous: prev.docs[doc._id],\n          affected: affected,\n          err: err\n        }, ctx), userId, doc, fields, prev.mutator, prev.options);\n      });\n    });\n  }\n\n  if (async) {\n    return _super.call(self, args[0], args[1], args[2], function (err, affected) {\n      after(affected, err);\n      return args[3].apply(this, arguments);\n    });\n  } else {\n    var affected = _super.apply(self, args);\n    after(affected);\n    return affected;\n  }\n});\n\n// This function contains a snippet of code pulled and modified from:\n// ~/.meteor/packages/mongo-livedata/collection.js:632-668\n// It's contained in these utility functions to make updates easier for us in\n// case this code changes.\nvar getFields = function (mutator) {\n  // compute modified fields\n  var fields = [];\n  _.each(mutator, function (params, op) {\n    _.each(_.keys(params), function (field) {\n      // treat dotted fields as if they are replacing their\n      // top-level part\n      if (field.indexOf('.') !== -1)\n        field = field.substring(0, field.indexOf('.'));\n\n      // record the field we are trying to change\n      if (!_.contains(fields, field))\n        fields.push(field);\n    });\n  });\n\n  return fields;\n};\n\n// This function contains a snippet of code pulled and modified from:\n// ~/.meteor/packages/mongo-livedata/collection.js\n// It's contained in these utility functions to make updates easier for us in\n// case this code changes.\nvar getFields = function (mutator) {\n  // compute modified fields\n  var fields = [];\n\n  _.each(mutator, function (params, op) {\n    //====ADDED START=======================\n    if (_.contains([\"$set\", \"$unset\", \"$inc\", \"$push\", \"$pull\", \"$pop\", \"$rename\", \"$pullAll\", \"$addToSet\", \"$bit\"], op)) {\n    //====ADDED END=========================\n      _.each(_.keys(params), function (field) {\n        // treat dotted fields as if they are replacing their\n        // top-level part\n        if (field.indexOf('.') !== -1)\n          field = field.substring(0, field.indexOf('.'));\n\n        // record the field we are trying to change\n        if (!_.contains(fields, field))\n          fields.push(field);\n      });\n    //====ADDED START=======================\n    } else {\n      fields.push(op);\n    }\n    //====ADDED END=========================\n  });\n\n  return fields;\n};","CollectionHooks.defineAdvice(\"remove\", function (userId, _super, aspects, getTransform, args) {\n  var self = this;\n  var ctx = {context: self, _super: _super, args: args};\n  var async = _.isFunction(_.last(args));\n  var docs, abort, prev = [];\n  var collection = _.has(self, \"_collection\") ? self._collection : self;\n\n  // args[0] : selector\n  // args[1] : callback\n\n  var docs = CollectionHooks.getDocs.call(self, collection, args[0]).fetch();\n\n  // copy originals for convenience for the \"after\" pointcut\n  if (aspects.after) {\n    _.each(docs, function (doc) {\n      prev.push(EJSON.clone(doc));\n    });\n  }\n\n  // before\n  _.each(aspects.before, function (aspect) {\n    _.each(docs, function (doc) {\n      var r = aspect.call(_.extend({transform: getTransform(doc)}, ctx), userId, doc);\n      if (r === false) abort = true;\n    });\n  });\n\n  if (abort) return false;\n\n  function after(err) {\n    _.each(aspects.after, function (aspect) {\n      _.each(prev, function (doc) {\n        aspect.call(_.extend({transform: getTransform(doc), err: err}, ctx), userId, doc);\n      });\n    });\n  }\n\n  if (async) {\n    return _super.call(self, args[0], function (err) {\n      after(err);\n      return args[1].apply(this, arguments);\n    });\n  } else {\n    var result = _super.apply(self, args);\n    after();\n    return result;\n  }\n});","CollectionHooks.defineAdvice(\"find\", function (userId, _super, aspects, getTransform, args) {\n  var self = this;\n  var ctx = {context: self, _super: _super, args: args};\n  var ret, abort;\n\n  // args[0] : selector\n  // args[1] : options\n\n  // before\n  _.each(aspects.before, function (aspect) {\n    var r = aspect.call(ctx, userId, args[0], args[1]);\n    if (r === false) abort = true;\n  });\n\n  if (abort) return false;\n\n  function after(cursor) {\n    _.each(aspects.after, function (aspect) {\n      aspect.call(ctx, userId, args[0], args[1], cursor);\n    });\n  }\n\n  ret = _super.apply(self, args);\n  after(ret);\n\n  return ret;\n});","CollectionHooks.defineAdvice(\"findOne\", function (userId, _super, aspects, getTransform, args) {\n  var self = this;\n  var ctx = {context: self, _super: _super, args: args};\n  var ret, abort;\n\n  // args[0] : selector\n  // args[1] : options\n\n  // before\n  _.each(aspects.before, function (aspect) {\n    var r = aspect.call(ctx, userId, args[0], args[1]);\n    if (r === false) abort = true;\n  });\n\n  if (abort) return false;\n\n  function after(doc) {\n    _.each(aspects.after, function (aspect) {\n      aspect.call(ctx, userId, args[0], args[1], doc);\n    });\n  }\n\n  ret = _super.apply(self, args);\n  after(ret);\n\n  return ret;\n});","if (Meteor.users) {\n  CollectionHooks.extendCollectionInstance(Meteor.users);\n}"]}