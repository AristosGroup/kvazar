{"version":3,"file":"/packages/oauth.js","sources":["oauth/oauth_server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,kC;AACA,6B;;AAEA,W;AACA,e;;AAEA,2C;;AAEA,4B;;AAEA,+D;AACA,sE;AACA,iB;AACA,E;AACA,4B;;;AAGA,sE;AACA,sE;AACA,mE;AACA,c;AACA,E;AACA,iD;AACA,iD;AACA,4D;AACA,2D;AACA,uF;AACA,yE;AACA,uB;AACA,yE;AACA,8C;AACA,wD;AACA,E;AACA,4E;AACA,+B;AACA,yE;;AAEA,8B;AACA,sB;AACA,qB;AACA,e;AACA,0C;AACA,I;AACA,E;;AAEA,oB;AACA,+C;AACA,kC;AACA,E;;;AAGA,mE;AACA,6D;AACA,mE;AACA,qE;AACA,E;AACA,qE;AACA,4C;AACA,E;AACA,+C;AACA,E;AACA,0C;;AAEA,iD;AACA,sE;AACA,C;;AAEA,sD;AACA,qE;AACA,+D;AACA,gB;AACA,C;;AAEA,yC;AACA,qD;AACA,gF;AACA,mD;AACA,qB;AACA,+B;AACA,W;AACA,G;;AAEA,wC;AACA,mE;AACA,e;AACA,O;AACA,4C;AACA,uB;AACA,uD;AACA,a;AACA,a;AACA,K;;AAEA,kD;;AAEA,wE;AACA,iB;AACA,iE;;AAEA,iC;AACA,kC;;AAEA,0D;AACA,iB;AACA,qE;AACA,qC;AACA,iB;AACA,oE;AACA,+D;AACA,M;AACA,oE;AACA,sE;AACA,iE;AACA,iD;AACA,gD;AACA,kE;;AAEA,+D;AACA,iE;AACA,4B;AACA,gD;AACA,kE;AACA,iD;AACA,oE;AACA,M;AACA,8D;AACA,+D;AACA,4C;AACA,oB;AACA,G;AACA,E;;AAEA,kC;;AAEA,sD;AACA,E;AACA,mE;AACA,gB;AACA,uC;AACA,sD;AACA,4D;AACA,sC;;AAEA,yD;AACA,iB;AACA,gC;AACA,gB;;AAEA,8B;AACA,iC;AACA,qB;AACA,E;;AAEA,6B;AACA,8C;AACA,6E;AACA,yE;AACA,I;AACA,E;;AAEA,mD;AACA,kD;AACA,gE;AACA,4B;AACA,yE;AACA,oB;AACA,8B;AACA,4D;AACA,yD;AACA,8D;AACA,+D;AACA,2C;AACA,+E;AACA,0E;AACA,uD;AACA,Y;AACA,yB;AACA,K;AACA,c;AACA,U;AACA,sD;AACA,yB;AACA,G;AACA,E;;AAEA,gC;AACA,oD;AACA,e;AACA,oE;AACA,4B;AACA,E","sourcesContent":["var Fiber = Npm.require('fibers');\nvar url = Npm.require('url');\n\nOauth = {};\nOauthTest = {};\n\nRoutePolicy.declare('/_oauth/', 'network');\n\nvar registeredServices = {};\n\n// Internal: Maps from service version to handler function. The\n// 'oauth1' and 'oauth2' packages manipulate this directly to register\n// for callbacks.\n//\nOauth._requestHandlers = {};\n\n\n// Register a handler for an OAuth service. The handler will be called\n// when we get an incoming http request on /_oauth/{serviceName}. This\n// handler should use that information to fetch data about the user\n// logging in.\n//\n// @param name {String} e.g. \"google\", \"facebook\"\n// @param version {Number} OAuth version (1 or 2)\n// @param urls   For OAuth1 only, specify the service's urls\n// @param handleOauthRequest {Function(oauthBinding|query)}\n//   - (For OAuth1 only) oauthBinding {OAuth1Binding} bound to the appropriate provider\n//   - (For OAuth2 only) query {Object} parameters passed in query string\n//   - return value is:\n//     - {serviceData:, (optional options:)} where serviceData should end\n//       up in the user's services[name] field\n//     - `null` if the user declined to give permissions\n//\nOauth.registerService = function (name, version, urls, handleOauthRequest) {\n  if (registeredServices[name])\n    throw new Error(\"Already registered the \" + name + \" OAuth service\");\n\n  registeredServices[name] = {\n    serviceName: name,\n    version: version,\n    urls: urls,\n    handleOauthRequest: handleOauthRequest\n  };\n};\n\n// For test cleanup.\nOauthTest.unregisterService = function (name) {\n  delete registeredServices[name];\n};\n\n\n// When we get an incoming OAuth http request we complete the oauth\n// handshake, account and token setup before responding.  The\n// results are stored in this map which is then read when the login\n// method is called. Maps credentialToken --> return value of `login`\n//\n// NB: the oauth1 and oauth2 packages manipulate this directly. might\n// be nice for them to have a setter instead\n//\n// XXX we should periodically clear old entries\n//\nOauth._loginResultForCredentialToken = {};\n\nOauth.hasCredential = function(credentialToken) {\n  return _.has(Oauth._loginResultForCredentialToken, credentialToken);\n}\n\nOauth.retrieveCredential = function(credentialToken) {\n  var result = Oauth._loginResultForCredentialToken[credentialToken];\n  delete Oauth._loginResultForCredentialToken[credentialToken];\n  return result;\n}\n\n// Listen to incoming OAuth http requests\nWebApp.connectHandlers.use(function(req, res, next) {\n  // Need to create a Fiber since we're using synchronous http calls and nothing\n  // else is wrapping this in a fiber automatically\n  Fiber(function () {\n    middleware(req, res, next);\n  }).run();\n});\n\nmiddleware = function (req, res, next) {\n  // Make sure to catch any exceptions because otherwise we'd crash\n  // the runner\n  try {\n    var serviceName = oauthServiceName(req);\n    if (!serviceName) {\n      // not an oauth request. pass to next middleware.\n      next();\n      return;\n    }\n\n    var service = registeredServices[serviceName];\n\n    // Skip everything if there's no service set by the oauth middleware\n    if (!service)\n      throw new Error(\"Unexpected OAuth service \" + serviceName);\n\n    // Make sure we're configured\n    ensureConfigured(serviceName);\n\n    var handler = Oauth._requestHandlers[service.version];\n    if (!handler)\n      throw new Error(\"Unexpected OAuth version \" + service.version);\n    handler(service, req.query, res);\n  } catch (err) {\n    // if we got thrown an error, save it off, it will get passed to\n    // the approporiate login call (if any) and reported there.\n    //\n    // The other option would be to display it in the popup tab that\n    // is still open at this point, ignoring the 'close' or 'redirect'\n    // we were passed. But then the developer wouldn't be able to\n    // style the error or react to it in any way.\n    if (req.query.state && err instanceof Error)\n      Oauth._loginResultForCredentialToken[req.query.state] = err;\n\n    // XXX the following is actually wrong. if someone wants to\n    // redirect rather than close once we are done with the OAuth\n    // flow, as supported by\n    // Oauth_renderOauthResults, this will still\n    // close the popup instead. Once we fully support the redirect\n    // flow (by supporting that in places such as\n    // packages/facebook/facebook_client.js) we should revisit this.\n    //\n    // close the popup. because nobody likes them just hanging\n    // there.  when someone sees this multiple times they might\n    // think to check server logs (we hope?)\n    closePopup(res);\n  }\n};\n\nOauthTest.middleware = middleware;\n\n// Handle /_oauth/* paths and extract the service name\n//\n// @returns {String|null} e.g. \"facebook\", or null if this isn't an\n// oauth request\nvar oauthServiceName = function (req) {\n  // req.url will be \"/_oauth/<service name>?<action>\"\n  var barePath = req.url.substring(0, req.url.indexOf('?'));\n  var splitPath = barePath.split('/');\n\n  // Any non-oauth request will continue down the default\n  // middlewares.\n  if (splitPath[1] !== '_oauth')\n    return null;\n\n  // Find service based on url\n  var serviceName = splitPath[2];\n  return serviceName;\n};\n\n// Make sure we're configured\nvar ensureConfigured = function(serviceName) {\n  if (!ServiceConfiguration.configurations.findOne({service: serviceName})) {\n    throw new ServiceConfiguration.ConfigError(\"Service not configured\");\n  };\n};\n\n// Internal: used by the oauth1 and oauth2 packages\nOauth._renderOauthResults = function(res, query) {\n  // We support ?close and ?redirect=URL. Any other query should\n  // just serve a blank page\n  if ('close' in query) { // check with 'in' because we don't set a value\n    closePopup(res);\n  } else if (query.redirect) {\n    // Only redirect to URLs on the same domain as this app.\n    // XXX No code in core uses this code path right now.\n    var redirectHostname = url.parse(query.redirect).hostname;\n    var appHostname = url.parse(Meteor.absoluteUrl()).hostname;\n    if (appHostname === redirectHostname) {\n      // We rely on node to make sure the header is really only a single header\n      // (not, for example, a url with a newline and then another header).\n      res.writeHead(302, {'Location': query.redirect});\n    } else {\n      res.writeHead(400);\n    }\n    res.end();\n  } else {\n    res.writeHead(200, {'Content-Type': 'text/html'});\n    res.end('', 'utf-8');\n  }\n};\n\nvar closePopup = function(res) {\n  res.writeHead(200, {'Content-Type': 'text/html'});\n  var content =\n        '<html><head><script>window.close()</script></head></html>';\n  res.end(content, 'utf-8');\n};\n"]}