{"version":3,"file":"/packages/autoupdate.js","sources":["autoupdate/autoupdate_server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,mE;AACA,sE;AACA,iD;AACA,E;AACA,mE;AACA,qE;AACA,2C;AACA,E;AACA,qE;AACA,mE;AACA,gE;AACA,mE;AACA,gE;AACA,uB;AACA,E;AACA,gE;AACA,sB;AACA,E;AACA,4D;AACA,qE;AACA,sE;AACA,oD;AACA,E;AACA,oE;AACA,mE;AACA,qE;AACA,mE;AACA,e;AACA,E;AACA,iE;AACA,oE;AACA,oE;AACA,E;AACA,qE;AACA,mE;AACA,0D;;AAEA,gB;;AAEA,oE;AACA,iE;AACA,kE;AACA,qB;;AAEA,oC;;AAEA,4B;AACA,iE;AACA,4B;AACA,4C;AACA,kC;AACA,uC;AACA,kD;AACA,wB;;AAEA,oD;AACA,6E;AACA,G;;;AAGA,e;AACA,qC;AACA,e;AACA,oB;AACA,oE;AACA,qE;AACA,6C;AACA,uC;AACA,iB;AACA,2C;AACA,qC;AACA,uB;AACA,Q;AACA,mB;AACA,Y;AACA,mD;AACA,gF;AACA,K;AACA,I;AACA,iB;AACA,E","sourcesContent":["// Publish the current client version to the client.  When a client\n// sees the subscription change and that there is a new version of the\n// client available on the server, it can reload.\n//\n// By default the current client version is identified by a hash of\n// the client resources seen by the browser (the HTML, CSS, code, and\n// static files in the `public` directory).\n//\n// If the environment variable `AUTOUPDATE_VERSION` is set it will be\n// used as the client id instead.  You can use this to control when\n// the client reloads.  For example, if you want to only force a\n// reload on major changes, you can use a custom AUTOUPDATE_VERSION\n// which you only change when something worth pushing to clients\n// immediately happens.\n//\n// For backwards compatibility, SERVER_ID can be used instead of\n// AUTOUPDATE_VERSION.\n//\n// The server publishes a `meteor_autoupdate_clientVersions`\n// collection.  The contract of this collection is that each document\n// in the collection represents an acceptable client version, with the\n// `_id` field of the document set to the client id.\n//\n// An \"unacceptable\" client version, for example, might be a version\n// of the client code which has a severe UI bug, or is incompatible\n// with the server.  An \"acceptable\" client version could be one that\n// is older than the latest client code available on the server but\n// still works.\n//\n// One of the published documents in the collection will have its\n// `current` field set to `true`.  This is the version of the client\n// code that the browser will receive from the server if it reloads.\n//\n// In this implementation only one document is published, the current\n// client version.  Developers can easily experiment with different\n// versioning and updating models by forking this package.\n\nAutoupdate = {};\n\n// The client hash includes __meteor_runtime_config__, so wait until\n// all packages have loaded and have had a chance to populate the\n// runtime config before using the client hash as our default auto\n// update version id.\n\nAutoupdate.autoupdateVersion = null;\n\nMeteor.startup(function () {\n  // Allow people to override Autoupdate.autoupdateVersion before\n  // startup. Tests do this.\n  if (Autoupdate.autoupdateVersion === null)\n    Autoupdate.autoupdateVersion =\n      process.env.AUTOUPDATE_VERSION ||\n      process.env.SERVER_ID || // XXX COMPAT 0.6.6\n      WebApp.clientHash;\n\n  // Make autoupdateVersion available on the client.\n  __meteor_runtime_config__.autoupdateVersion = Autoupdate.autoupdateVersion;\n});\n\n\nMeteor.publish(\n  \"meteor_autoupdate_clientVersions\",\n  function () {\n    var self = this;\n    // Using `autoupdateVersion` here is safe because we can't get a\n    // subscription before webapp starts listening, and it doesn't do\n    // that until the startup hooks have run.\n    if (Autoupdate.autoupdateVersion) {\n      self.added(\n        \"meteor_autoupdate_clientVersions\",\n        Autoupdate.autoupdateVersion,\n        {current: true}\n      );\n      self.ready();\n    } else {\n      // huh? shouldn't happen. Just error the sub.\n      self.error(new Meteor.Error(500, \"Autoupdate.autoupdateVersion not set\"));\n    }\n  },\n  {is_auto: true}\n);\n"]}