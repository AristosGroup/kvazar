{"version":3,"file":"/packages/handlebars.js","sources":["handlebars/parse-handlebars.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAAA,gB;;AAEA,c;AACA,E;AACA,yD;AACA,6B;AACA,6C;AACA,+C;AACA,uC;AACA,8C;AACA,sC;AACA,8D;AACA,E;AACA,sE;AACA,qE;AACA,E;AACA,sB;AACA,6B;AACA,wE;AACA,kC;AACA,E;AACA,gE;AACA,E;AACA,oE;AACA,+D;AACA,Y;AACA,G;;AAEA,+B;AACA,sC;;AAEA,6B;AACA,kD;AACA,yB;AACA,W;AACA,qB;AACA,E;;AAEA,kE;AACA,qE;AACA,qB;;AAEA,gE;AACA,wB;AACA,E;AACA,0C;AACA,O;AACA,gC;AACA,e;AACA,gE;AACA,kE;AACA,oE;AACA,+D;AACA,oE;AACA,oE;AACA,8D;AACA,6B;AACA,oE;AACA,U;AACA,oE;;AAEA,kB;AACA,iD;;AAEA,Y;AACA,G;;AAEA,oE;AACA,2E;AACA,oC;;AAEA,oC;AACA,2B;AACA,uE;AACA,oE;AACA,6D;AACA,sE;AACA,c;AACA,2B;AACA,0E;AACA,4E;AACA,2E;AACA,oB;AACA,sC;AACA,mB;AACA,kC;AACA,I;;AAEA,+B;AACA,mE;AACA,qE;AACA,4B;AACA,2D;AACA,yB;AACA,4B;AACA,iC;AACA,K;;AAEA,mB;AACA,qD;AACA,oD;AACA,uD;AACA,+D;AACA,M;AACA,gC;AACA,kE;AACA,oC;AACA,I;;AAEA,8B;AACA,6B;AACA,iE;AACA,iB;AACA,qC;AACA,8B;AACA,O;AACA,e;AACA,I;;AAEA,oC;AACA,iC;AACA,uE;AACA,wB;AACA,kC;AACA,4B;AACA,kB;AACA,gC;AACA,e;AACA,I;;AAEA,mC;AACA,iB;;AAEA,e;AACA,gB;;AAEA,mB;AACA,iC;AACA,+D;AACA,Q;AACA,gC;AACA,qC;AACA,2C;AACA,gE;AACA,kD;AACA,yE;AACA,6B;AACA,yB;AACA,kE;AACA,oB;AACA,Q;AACA,8B;AACA,gD;AACA,oD;AACA,iC;AACA,4D;AACA,oB;AACA,Q;AACA,gC;AACA,iD;AACA,yC;AACA,kE;AACA,sD;AACA,Q;AACA,wD;AACA,iC;AACA,M;;AAEA,mC;AACA,kC;AACA,sE;AACA,+B;AACA,O;;AAEA,e;AACA,I;;AAEA,6B;AACA,kE;AACA,kC;AACA,E;;AAEA,mD;AACA,uC;AACA,2B;AACA,sE;AACA,iC;AACA,oD;AACA,I;AACA,0C;AACA,0D;AACA,E","sourcesContent":["Handlebars = {};\n\n/* Our format:\n *\n * A 'template' is an array. Each element in it is either\n * - a literal string to echo\n * - an escaped substition: ['{', invocation]\n * - an unescaped substition: ['!', invocation]\n * - a (conditional or iterated) block:\n *   ['#', invocation, template_a, template_b]\n *   (the second template is optional)\n * - a partial: ['>', partial_name] (partial_name is a string)\n *\n * An 'invocation' is an array: one or more 'values', then an optional\n * hash (of which the keys are strings, and the values are 'values'.)\n *\n * An 'identifier' is:\n * - [depth, key, key, key..]\n * Eg, '../../a.b.c' would be [2, 'a', 'b', 'c']. 'a' would be [0, 'a'].\n * And 'this' or '.' would be [0].\n *\n * A 'value' is either an identifier, or a string, int, or bool.\n *\n * You should provide a block helper 'with' since we will emit calls\n * to it (if the user passes the second 'context' argument to a\n * partial.)\n */\n\nvar path = Npm.require('path');\nvar hbars = Npm.require('handlebars');\n\n// Has keys 'message', 'line'\nHandlebars.ParseError = function (message, line) {\n  this.message = message;\n  if (line)\n    this.line = line;\n};\n\n// Raises Handlebars.ParseError if the Handlebars parser fails. We\n// will do our best to decode the output of Handlebars into a message\n// and a line number.\n\n// If Handlebars parsing fails, the Handlebars parser error will\n// escape to the caller.\n//\nHandlebars.to_json_ast = function (code) {\n  try {\n    var ast = hbars.parse(code);\n  } catch (e) {\n    // The Handlebars parser throws Error objects with a message\n    // attribute (and nothing else) and we must do our best. Parse\n    // errors include a line number (relative to the start of 'code'\n    // of course) which we'll attempt to parse out. (Handlebars\n    // almost, but not quite copies the line number information onto\n    // the Error object.) Other than parse errors, you also see very\n    // short strings like \"else doesn't match unless\" (with no\n    // location information.)\n    var m = e.message.match(/^Parse error on line (\\d+):([\\s\\S]*)$/)\n    if (m)\n      throw new Handlebars.ParseError(\"Parse error:\" + m[2], +m[1]);\n\n    if (e.message)\n      throw new Handlebars.ParseError(e.message);\n\n    throw e;\n  }\n\n  // Recreate Handlebars.Exception to properly report error messages\n  // and stack traces. (https://github.com/wycats/handlebars.js/issues/226)\n  makeHandlebarsExceptionsVisible();\n\n  var identifier = function (node) {\n    if (node.type !== \"ID\")\n      throw new Error(\"got ast node \" + node.type + \" for identifier\");\n    // drop node.isScoped. this is true if there was a 'this' or '.'\n    // anywhere in the path. vanilla handlebars will turn off\n    // helpers lookup if isScoped is true, but this is too restrictive\n    // for us.\n    var ret = [node.depth];\n    // we still want to turn off helper lookup if path starts with 'this.'\n    // as in {{this.foo}}, which means it has to look different from {{foo}}\n    // in our AST.  signal the presence of 'this' in our AST using an empty\n    // path segment.\n    if (/^this\\./.test(node.original))\n      ret.push('');\n    return ret.concat(node.parts);\n  };\n\n  var value = function (node) {\n    // Work around handlebars.js Issue #422 - Negative integers for\n    // helpers get trapped as ID. handlebars doesn't support floating\n    // point, just integers.\n    if (node.type === 'ID' && /^-\\d+$/.test(node.string)) {\n      // Reconstruct node\n      node.type = 'INTEGER';\n      node.integer = node.string;\n    }\n\n    var choices = {\n      ID: function (node) {return identifier(node);},\n      STRING: function (node) {return node.string;},\n      INTEGER: function (node) {return +node.integer;},\n      BOOLEAN: function (node) {return (node.bool === 'true');}\n    };\n    if (!(node.type in choices))\n      throw new Error(\"got ast node \" + node.type + \" for value\");\n    return choices[node.type](node);\n  };\n\n  var hash = function (node) {\n    if (node.type !== \"hash\")\n      throw new Error(\"got ast node \" + node.type + \" for hash\");\n    var ret = {};\n    _.each(node.pairs, function (p) {\n      ret[p[0]] = value(p[1]);\n    });\n    return ret;\n  };\n\n  var invocation = function (node) {\n    if (node.type !== \"mustache\")\n      throw new Error(\"got ast node \" + node.type + \" for invocation\");\n    var ret = [node.id];\n    ret = ret.concat(node.params);\n    ret = _.map(ret, value);\n    if (node.hash)\n      ret.push(hash(node.hash));\n    return ret;\n  };\n\n  var template = function (nodes) {\n    var ret = [];\n\n    if (!nodes)\n      return [];\n\n    var choices = {\n      mustache: function (node) {\n        ret.push([node.escaped ? '{' : '!', invocation(node)]);\n      },\n      partial: function (node) {\n        var id = identifier(node.id);\n        if (id.length !== 2 || id[0] !== 0)\n          // XXX actually should just get the literal string the\n          // entered, and avoid identifier parsing\n          throw new Error(\"Template names shouldn't contain '.' or '/'\");\n        var x = ['>', id[1]];\n        if (node.context)\n          x = ['#', [[0, 'with'], identifier(node.context)], [x]];\n        ret.push(x);\n      },\n      block: function (node) {\n        var x = ['#', invocation(node.mustache),\n                 template(node.program.statements)];\n        if (node.program.inverse)\n          x.push(template(node.program.inverse.statements));\n        ret.push(x);\n      },\n      inverse: function (node) {\n        ret.push(['#', invocation(node.mustache),\n                  node.program.inverse &&\n                  template(node.program.inverse.statements) || [],\n                  template(node.program.statements)]);\n      },\n      content: function (node) {ret.push(node.string);},\n      comment: function (node) {}\n    };\n\n    _.each(nodes, function (node) {\n      if (!(node.type in choices))\n        throw new Error(\"got ast node \" + node.type + \" in template\");\n      choices[node.type](node);\n    });\n\n    return ret;\n  };\n\n  if (ast.type !== \"program\")\n    throw new Error(\"got ast node \" + node.type + \" at toplevel\");\n  return template(ast.statements);\n};\n\nvar makeHandlebarsExceptionsVisible = function () {\n  hbars.Exception = function(message) {\n    this.message = message;\n    // In Node, if we don't do this we don't see the message displayed\n    // nor the right stack trace.\n    Error.captureStackTrace(this, arguments.callee);\n  };\n  hbars.Exception.prototype = new Error();\n  hbars.Exception.prototype.name = 'Handlebars.Exception';\n};\n"]}