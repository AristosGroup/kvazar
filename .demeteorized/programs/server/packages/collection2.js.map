{"version":3,"file":"/packages/collection2.js","sources":["collection2/collection2.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA,oD;AACA,4B;AACA,kC;AACA,sC;AACA,sC;AACA,qC;AACA,G;;AAEA,8C;AACA,qD;;AAEA,8C;AACA,mE;AACA,G;;AAEA,0B;;AAEA,+B;AACA,uE;AACA,G;;AAEA,uB;AACA,+C;AACA,wC;AACA,U;AACA,0D;AACA,G;AACA,wB;;AAEA,0B;AACA,8C;AACA,mC;AACA,iC;AACA,G;;AAEA,wB;AACA,wB;AACA,uE;AACA,oC;AACA,yD;AACA,K;AACA,K;;AAEA,mC;AACA,uC;AACA,oF;AACA,8G;AACA,8B;AACA,2B;AACA,8B;AACA,oD;AACA,yC;AACA,+E;AACA,qE;AACA,qC;AACA,W;AACA,+D;AACA,wD;AACA,Q;AACA,+E;AACA,K;AACA,2B;AACA,0C;AACA,0C;AACA,U;AACA,2B;AACA,8B;AACA,wC;AACA,yC;AACA,+E;AACA,qE;AACA,qC;AACA,W;AACA,+D;AACA,wD;AACA,Q;AACA,K;AACA,2B;AACA,sB;AACA,iB;AACA,6B;AACA,+B;AACA,2B;AACA,K;AACA,2D;AACA,mE;AACA,Y;AACA,8D;AACA,K;AACA,G;AACA,2C;AACA,oF;AACA,yB;AACA,mC;AACA,6B;AACA,2D;AACA,4B;AACA,M;AACA,mE;AACA,yB;AACA,uC;AACA,gC;AACA,0B;AACA,S;AACA,S;;AAEA,uE;AACA,gD;AACA,uE;AACA,yE;AACA,iC;AACA,qE;AACA,yE;AACA,8B;AACA,O;;AAEA,gF;AACA,8E;AACA,kD;AACA,gC;AACA,+D;AACA,qC;AACA,sC;AACA,W;AACA,W;AACA,O;;AAEA,iE;AACA,oD;AACA,wC;AACA,M;AACA,qD;AACA,uE;AACA,6D;AACA,M;AACA,6B;AACA,uE;AACA,M;AACA,6B;AACA,gE;AACA,iC;AACA,M;AACA,mE;AACA,yB;AACA,4C;AACA,gC;AACA,+B;AACA,S;AACA,S;;AAEA,iE;AACA,oD;AACA,iE;AACA,sF;AACA,gF;AACA,kC;AACA,qF;AACA,uG;AACA,uC;AACA,mF;AACA,M;AACA,c;AACA,mB;AACA,K;AACA,uE;AACA,sE;AACA,wC;AACA,6F;AACA,4B;AACA,0B;AACA,oB;AACA,Q;AACA,0B;AACA,oB;AACA,Q;AACA,0B;AACA,oB;AACA,Q;AACA,gB;AACA,qB;AACA,O;AACA,G;AACA,E;AACA,6B;AACA,4D;AACA,oD;AACA,I;AACA,kD;AACA,gF;AACA,gC;AACA,K;AACA,I;AACA,+B;AACA,gF;AACA,+D;AACA,kC;AACA,O;AACA,K;AACA,I;AACA,2D;AACA,kB;AACA,K;AACA,I;AACA,qB;AACA,gB;AACA,sB;AACA,0B;AACA,8B;AACA,6E;AACA,S;AACA,0C;AACA,yD;AACA,6B;AACA,sB;;AAEA,mG;AACA,6B;AACA,oC;AACA,2B;;AAEA,6C;AACA,uG;AACA,mC;AACA,gB;AACA,yB;AACA,oE;AACA,S;;AAEA,mD;AACA,sE;AACA,c;AACA,mE;AACA,O;AACA,K;AACA,I;AACA,gB;AACA,K;AACA,E;;AAEA,qE;AACA,kB;AACA,wC;AACA,sC;AACA,kD;;AAEA,qB;AACA,oD;AACA,G;;AAEA,gC;AACA,0B;AACA,kB;AACA,sB;AACA,uB;AACA,sD;AACA,6B;AACA,kB;AACA,sB;AACA,uB;AACA,U;AACA,6C;AACA,G;;AAEA,mD;AACA,uB;AACA,iB;AACA,G;;AAEA,0B;;AAEA,iF;AACA,mF;;AAEA,iE;AACA,qD;AACA,oF;AACA,sB;AACA,G;;AAEA,oF;AACA,qC;AACA,kE;AACA,iE;AACA,8D;AACA,mE;AACA,Y;AACA,8B;AACA,c;AACA,sE;AACA,M;AACA,G;;AAEA,0B;;AAEA,yB;AACA,kE;AACA,oE;AACA,uE;AACA,wB;AACA,wE;AACA,G;;AAEA,4E;AACA,2E;AACA,0E;AACA,0E;AACA,4E;AACA,4C;AACA,mC;AACA,kE;AACA,uC;AACA,iD;AACA,sC;AACA,G;AACA,E;AACA,sD;AACA,wB;AACA,4F;AACA,G;;AAEA,gB;AACA,wF;AACA,uD;AACA,qB;AACA,oE;AACA,kB;AACA,sB;AACA,K;AACA,gC;;AAEA,gB;AACA,4B;AACA,oD;AACA,uD;AACA,mC;AACA,oD;AACA,uD;AACA,mC;AACA,oD;AACA,uD;AACA,K;AACA,U;AACA,2C;AACA,mB;AACA,sB;AACA,kB;AACA,K;AACA,gB;AACA,G;AACA,E;;AAEA,iE;AACA,kC;AACA,8C;AACA,E;;AAEA,iE;AACA,kC;AACA,8C;AACA,E;;AAEA,iE;AACA,+B;AACA,0E;;AAEA,kC;AACA,8C;AACA,E;;AAEA,wD;AACA,4B;AACA,E;;AAEA,4D;AACA,4D;AACA,+C;AACA,E;;AAEA,uE;AACA,gE;AACA,0B;AACA,qC;AACA,2F;AACA,E;;AAEA,0E;AACA,4E;AACA,0B;AACA,qC;AACA,uG;AACA,E;;AAEA,sB;;AAEA,iE;AACA,iD;AACA,wD;AACA,E;;AAEA,gE;AACA,iD;AACA,uD;AACA,E;;AAEA,+D;AACA,iD;AACA,sD;AACA,E;;AAEA,+D;AACA,iD;AACA,sD;AACA,E;;AAEA,kE;AACA,iD;AACA,yD;AACA,E;;AAEA,6D;AACA,yC;AACA,kB;AACA,kC;AACA,sD;AACA,4F;AACA,wB;AACA,+B;AACA,oC;AACA,oC;AACA,oC;AACA,+C;AACA,0B;AACA,uB;AACA,Q;AACA,2B;AACA,iC;AACA,8B;AACA,wF;AACA,gB;AACA,4C;AACA,+B;AACA,oC;AACA,U;AACA,O;AACA,Y;;AAEA,+B;AACA,2C;AACA,a;AACA,K;;AAEA,8D;AACA,6B;AACA,kB;AACA,gC;AACA,kC;AACA,2E;AACA,mC;AACA,+J;AACA,W;AACA,mB;AACA,oC;AACA,gB;AACA,S;AACA,O;AACA,K;AACA,I;AACA,oD;AACA,2C;AACA,kB;AACA,K;;AAEA,6B;AACA,qE;AACA,2D;AACA,kD;AACA,sD;AACA,Y;AACA,gC;AACA,2C;AACA,K;AACA,K;AACA,0B;AACA,E","sourcesContent":["// Extend the schema options allowed by SimpleSchema\nSimpleSchema.extendOptions({\n  unique: Match.Optional(Boolean),\n  autoValue: Match.Optional(Function),\n  denyInsert: Match.Optional(Boolean),\n  denyUpdate: Match.Optional(Boolean)\n});\n\nMeteor.Collection2 = function(name, options) {\n  var self = this, userTransform, existingCollection;\n\n  if (!(self instanceof Meteor.Collection2)) {\n    throw new Error('use \"new\" to construct a Meteor.Collection2');\n  }\n\n  options = options || {};\n\n  if (!(\"schema\" in options)) {\n    throw new Error('Meteor.Collection2 options must define a schema');\n  }\n\n  //set up simpleSchema\n  if (options.schema instanceof SimpleSchema) {\n    self._simpleSchema = options.schema;\n  } else {\n    self._simpleSchema = new SimpleSchema(options.schema);\n  }\n  delete options.schema;\n\n  //get the virtual fields\n  self._virtualFields = options.virtualFields;\n  if (\"virtualFields\" in options) {\n    delete options.virtualFields;\n  }\n\n  //populate _autoValues\n  self._autoValues = {};\n  _.each(self._simpleSchema.schema(), function(definition, fieldName) {\n    if ('autoValue' in definition) {\n      self._autoValues[fieldName] = definition.autoValue;\n    }\n  });\n\n  //create or update the collection\n  if (name instanceof Meteor.Collection\n          || (\"SmartCollection\" in Meteor && name instanceof Meteor.SmartCollection)\n          || (typeof Offline === \"object\" && \"Collection\" in Offline && name instanceof Offline.Collection)) {\n    existingCollection = name;\n    //set up virtual fields\n    if (self._virtualFields) {\n      userTransform = existingCollection._transform;\n      options.transform = function(doc) {\n        //add all virtual fields to document whenever it's passed to a callback\n        _.each(self._virtualFields, function(func, fieldName, list) {\n          doc[fieldName] = func(doc);\n        });\n        //support user-supplied transformation function as well\n        return userTransform ? userTransform(doc) : doc;\n      };\n      existingCollection._transform = Deps._makeNonreactive(options.transform);\n    }\n    //update the collection\n    self._name = existingCollection._name;\n    self._collection = existingCollection;\n  } else {\n    //set up virtual fields\n    if (self._virtualFields) {\n      userTransform = options.transform;\n      options.transform = function(doc) {\n        //add all virtual fields to document whenever it's passed to a callback\n        _.each(self._virtualFields, function(func, fieldName, list) {\n          doc[fieldName] = func(doc);\n        });\n        //support user-supplied transformation function as well\n        return userTransform ? userTransform(doc) : doc;\n      };\n    }\n    //create the collection\n    self._name = name;\n    var useSmart;\n    if (\"smart\" in options) {\n      useSmart = options.smart;\n      delete options.smart;\n    }\n    if (useSmart === true && \"SmartCollection\" in Meteor) {\n      self._collection = new Meteor.SmartCollection(name, options);\n    } else {\n      self._collection = new Meteor.Collection(name, options);\n    }\n  }\n  //Validate from the real collection, too.\n  //This prevents doing C2._collection.insert(invalidDoc) (and update) on the client\n  self._collection.deny({\n    insert: function(userId, doc) {\n      // Set automatic values\n      var newDoc = getAutoValues.call(self, doc, \"insert\");\n      _.extend(doc, newDoc);\n      \n      // In case the call to getAutoValues removed anything, remove\n      // it from doc, too\n      _.each(doc, function (val, key) {\n        if (! (key in newDoc)) {\n          delete doc[key];\n        }\n      });\n\n      // At this point the _id has been autogenerated and added to doc,\n      // and any virtual fields have been added,\n      // which makes it different from what we validated on the client.\n      // Clone doc, remove _id and virtual fields, and validate the clone\n      var docCopy = _.clone(doc);\n      if (\"_id\" in docCopy && !self._simpleSchema.allowsKey(\"_id\")) {\n        // Remove _id only if _id doesn't have a definition in the schema\n        delete docCopy[\"_id\"];\n      }\n\n      // The virtualFields should not be present because we set transform: null,\n      // but we'll check for them in case it's an older version of Meteor that\n      // doesn't recognize the null transform flag\n      if (self._virtualFields) {\n        _.each(self._virtualFields, function(func, fieldName) {\n          if (fieldName in docCopy) {\n            delete docCopy[fieldName];\n          }\n        });\n      }\n\n      // Get a throwaway context here to avoid mixing up contexts\n      var context = self._simpleSchema.newContext();\n      return !context.validate(docCopy);\n    },\n    update: function(userId, doc, fields, modifier) {\n      // NOTE: This will never be an upsert because client-side upserts\n      // are not allowed once you define allow/deny functions\n      \n      // Set automatic values\n      _.extend(modifier, getAutoValues.call(self, modifier, \"update\"));\n      \n      // Set automatic values\n      var newMod = getAutoValues.call(self, modifier, \"update\");\n      _.extend(modifier, newMod);\n      \n      // In case the call to getAutoValues removed anything, remove\n      // it from doc, too\n      _.each(modifier, function (val, key) {\n        if (! (key in newMod)) {\n          delete modifier[key];\n        }\n      });\n\n      // Get a throwaway context here to avoid mixing up contexts\n      var context = self._simpleSchema.newContext();\n      var isValid = context.validate(modifier, {modifier: true});\n      // Ignore any notUnique errors until we can figure out how to make them accurate\n      // i.e., don't count any docs that will be updated by this update selector\n      // if that is even possible.\n      // Note that unique validation is still done on the client, so that would catch\n      // most non-malicious errors. Implementing a unique index in mongo will protect against the rest.\n      var keys = context.invalidKeys();\n      return !isValid && _.where(keys, {type: \"notUnique\"}).length !== keys.length;\n    },\n    fetch: [],\n    transform: null\n  });\n  //when the insecure package is used, we will confuse developers if we\n  //don't add allow functions because the deny functions that we added\n  //will \"turn off\" the insecure package\n  if (typeof Package === 'object' && Package.insecure) { //Package is not available pre-0.6.5\n    self._collection.allow({\n      insert: function() {\n        return true;\n      },\n      update: function() {\n        return true;\n      },\n      remove: function() {\n        return true;\n      },\n      fetch: [],\n      transform: null\n    });\n  }\n  \n  // Set up additional checks\n  self._simpleSchema.validator(function(key, val, def, op) {\n    var test, totalUsing, usingAndBeingUpdated, sel;\n    \n    if (def.denyInsert && val !== void 0 && !op) {\n      // This is an insert of a defined value into a field where denyInsert=true\n      return \"insertNotAllowed\";\n    }\n    \n    if (def.denyUpdate && op) {\n      // This is an insert of a defined value into a field where denyUpdate=true\n      if (op !== \"$set\" || (op === \"$set\" && val !== void 0)) {\n        return \"updateNotAllowed\";\n      }\n    }\n    \n    if ((val === void 0 || val === null) && def.optional) {\n      return true;\n    }\n    \n    if (def.unique) {\n      test = {};\n      test[key] = val;\n      if (op) { //updating\n        if (!self._selector) {\n          return true; //we can't determine whether we have a notUnique error\n        }\n        //find count of all with key = val\n        totalUsing = self._collection.find(test).count();\n        if (totalUsing === 0)\n          return true;\n\n        //find all that match selector for current update operation and also have key = val already\n        sel = self._selector;\n        if (typeof sel === \"string\")\n          sel = {_id: sel};\n\n        if (key in sel && sel[key] !== val) {\n          //if we're selecting on the unique key with a different value, usingAndBeingUpdated must be 0\n          usingAndBeingUpdated = 0;\n        } else {\n          sel[key] = val;\n          usingAndBeingUpdated = self._collection.find(sel).count();\n        }\n\n        //if first count > second count, not unique\n        return totalUsing > usingAndBeingUpdated ? \"notUnique\" : true;\n      } else {\n        return self._collection.findOne(test) ? \"notUnique\" : true;\n      }\n    }\n    \n    return true;\n  });\n};\n\nMeteor.Collection2.prototype._insertOrUpdate = function(type, args) {\n  var self = this,\n          collection = self._collection,\n          schema = self._simpleSchema,\n          doc, callback, error, options, isUpsert;\n\n  if (!args.length) {\n    throw new Error(type + \" requires an argument\");\n  }\n\n  self._selector = null; //reset\n  if (type === \"insert\") {\n    doc = args[0];\n    options = args[1];\n    callback = args[2];\n  } else if (type === \"update\" || type === \"upsert\") {\n    self._selector = args[0];\n    doc = args[1];\n    options = args[2];\n    callback = args[3];\n  } else {\n    throw new Error(\"invalid type argument\");\n  }\n\n  if (!callback && typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n\n  //if update was called with upsert:true or upsert was called, flag as an upsert\n  isUpsert = (type === \"upsert\" || (type === \"update\" && options.upsert === true));\n\n  //remove the options from insert now that we're done with them;\n  //the real insert does not have an options argument\n  if (type === \"insert\" && args[1] !== void 0 && !(typeof args[1] === \"function\")) {\n    args.splice(1, 1);\n  }\n\n  //add a default callback function if we're on the client and no callback was given\n  if (Meteor.isClient && !callback) {\n    // Client can't block, so it can't report errors by exception,\n    // only by callback. If they forget the callback, give them a\n    // default one that logs the error, so they aren't totally\n    // baffled if their writes don't work because their database is\n    // down.\n    callback = function(err) {\n      if (err)\n        Meteor._debug(type + \" failed: \" + (err.reason || err.stack));\n    };\n  }\n\n  doc = schema.clean(doc);\n\n  // Set automatic values\n  // On the server, we actually update the doc, but on the client,\n  // we will add them to docToValidate for validation purposes only.\n  // This is because we want all actual values generated on the server.\n  if (Meteor.isServer) {\n    doc = getAutoValues.call(self, doc, ( isUpsert ? \"upsert\" : type ));\n  }\n\n  //On the server, upserts are possible; SimpleSchema handles upserts pretty\n  //well by default, but it will not know about the fields in the selector,\n  //which are also stored in the database if an insert is performed. So we\n  //will allow these fields to be considered for validation by adding them\n  //to the $set in the modifier. This is no doubt prone to errors, but there\n  //probably isn't any better way right now.\n  var docToValidate = _.clone(doc);\n  if (Meteor.isServer && isUpsert && _.isObject(self._selector)) {\n    var set = docToValidate.$set || {};\n    docToValidate.$set = _.clone(self._selector);\n    _.extend(docToValidate.$set, set);\n  }\n  \n  // Set automatic values for validation on the client\n  if (Meteor.isClient) {\n    docToValidate = getAutoValues.call(self, docToValidate, ( isUpsert ? \"upsert\" : type ));\n  }\n\n  //validate doc\n  var isValid = schema.namedContext(options.validationContext).validate(docToValidate, {\n    modifier: (type === \"update\" || type === \"upsert\"),\n    upsert: isUpsert,\n    // Skip filter and autoconvert because we already called clean()\n    filter: false,\n    autoConvert: false\n  });\n  self._selector = null; //reset\n\n  if (isValid) {\n    if (type === \"insert\") {\n      args[0] = doc; //update to reflect cleaned doc\n      return collection.insert.apply(collection, args);\n    } else if (type === \"update\") {\n      args[1] = doc; //update to reflect cleaned doc\n      return collection.update.apply(collection, args);\n    } else if (type === \"upsert\") {\n      args[1] = doc; //update to reflect cleaned doc\n      return collection.upsert.apply(collection, args);\n    }\n  } else {\n    error = new Error(\"failed validation\");\n    if (callback) {\n      callback(error);\n      return null;\n    }\n    throw error;\n  }\n};\n\nMeteor.Collection2.prototype.insert = function(/* arguments */) {\n  var args = _.toArray(arguments);\n  return this._insertOrUpdate(\"insert\", args);\n};\n\nMeteor.Collection2.prototype.update = function(/* arguments */) {\n  var args = _.toArray(arguments);\n  return this._insertOrUpdate(\"update\", args);\n};\n\nMeteor.Collection2.prototype.upsert = function(/* arguments */) {\n  if (!this._collection.upsert)\n    throw new Error(\"Meteor 0.6.6 or higher is required to do an upsert\");\n\n  var args = _.toArray(arguments);\n  return this._insertOrUpdate(\"upsert\", args);\n};\n\nMeteor.Collection2.prototype.simpleSchema = function() {\n  return this._simpleSchema;\n};\n\n//DEPRECATED; Use myC2.simpleSchema().namedContext() instead\nMeteor.Collection2.prototype.namedContext = function(name) {\n  return this._simpleSchema.namedContext(name);\n};\n\n//DEPRECATED; Use myC2.simpleSchema().namedContext().validate() instead\nMeteor.Collection2.prototype.validate = function(doc, options) {\n  options = options || {};\n  // Validate doc and return validity\n  return this._simpleSchema.namedContext(options.validationContext).validate(doc, options);\n};\n\n//DEPRECATED; Use myC2.simpleSchema().namedContext().validateOne() instead\nMeteor.Collection2.prototype.validateOne = function(doc, keyName, options) {\n  options = options || {};\n  // Validate doc and return validity\n  return this._simpleSchema.namedContext(options.validationContext).validateOne(doc, keyName, options);\n};\n\n//Pass-through Methods\n\nMeteor.Collection2.prototype.remove = function(/* arguments */) {\n  var self = this, collection = self._collection;\n  return collection.remove.apply(collection, arguments);\n};\n\nMeteor.Collection2.prototype.allow = function(/* arguments */) {\n  var self = this, collection = self._collection;\n  return collection.allow.apply(collection, arguments);\n};\n\nMeteor.Collection2.prototype.deny = function(/* arguments */) {\n  var self = this, collection = self._collection;\n  return collection.deny.apply(collection, arguments);\n};\n\nMeteor.Collection2.prototype.find = function(/* arguments */) {\n  var self = this, collection = self._collection;\n  return collection.find.apply(collection, arguments);\n};\n\nMeteor.Collection2.prototype.findOne = function(/* arguments */) {\n  var self = this, collection = self._collection;\n  return collection.findOne.apply(collection, arguments);\n};\n\n// Updates doc with automatic values from autoValue functions\nvar getAutoValues = function(doc, type) {\n  var self = this;\n  var mDoc = new MongoObject(doc);\n  _.each(self._autoValues, function(func, fieldName) {\n    var keyInfo = mDoc.getArrayInfoForKey(fieldName) || mDoc.getInfoForKey(fieldName) || {};\n    var doUnset = false;\n    var autoValue = func.call({\n      isInsert: (type === \"insert\"),\n      isUpdate: (type === \"update\"),\n      isUpsert: (type === \"upsert\"),\n      isSet: mDoc.affectsGenericKey(fieldName),\n      unset: function () {\n        doUnset = true;\n      },\n      value: keyInfo.value,\n      operator: keyInfo.operator,\n      field: function(fName) {\n        var keyInfo = mDoc.getArrayInfoForKey(fName) || mDoc.getInfoForKey(fName) || {};\n        return {\n          isSet: (keyInfo.value !== void 0),\n          value: keyInfo.value,\n          operator: keyInfo.operator\n        };\n      }\n    }, doc);\n\n    if (autoValue === void 0) {\n      doUnset && mDoc.removeKey(fieldName);\n      return;\n    }\n\n    var fieldNameHasDollar = (fieldName.indexOf(\".$\") !== -1);\n    var newValue = autoValue;\n    var op = null;\n    if (_.isObject(autoValue)) {\n      for (var key in autoValue) {\n        if (autoValue.hasOwnProperty(key) && key.substring(0, 1) === \"$\") {\n          if (fieldNameHasDollar) {\n            throw new Error(\"The return value of an autoValue function may not be an object with update operators when the field name contains a dollar sign\");\n          }\n          op = key;\n          newValue = autoValue[key];\n          break;\n        }\n      }\n    }\n    \n    // Add $set for updates and upserts if necessary\n    if (op === null && type !== \"insert\") {\n      op = \"$set\";\n    }\n\n    if (fieldNameHasDollar) {\n      // There is no way to know which specific keys should be set to\n      // the autoValue, so we will set only keys that exist\n      // in the object and match this generic key.\n      mDoc.setValueForGenericKey(fieldName, newValue);\n    } else {\n      mDoc.removeKey(fieldName);\n      mDoc.addKey(fieldName, newValue, op);\n    }\n  });\n  return mDoc.getObject();\n};"]}