{"version":3,"file":"/packages/streams.js","sources":["streams/lib/ev.js","streams/lib/server.js","streams/lib/stream_permission.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAAA,gB;AACA,kB;AACA,oB;;AAEA,oC;AACA,wD;;AAEA,yB;AACA,sD;AACA,0C;AACA,kC;AACA,O;AACA,K;AACA,I;;AAEA,0C;AACA,0B;AACA,2B;AACA,K;AACA,mC;AACA,I;;AAEA,8C;AACA,+C;AACA,sC;AACA,kD;AACA,O;AACA,I;;AAEA,kE;AACA,yB;AACA,oD;AACA,uC;AACA,K;AACA,I;;AAEA,gE;AACA,gC;AACA,I;AACA,C;;AAEA,S;;;;;;;;;;;;;;;;;;ACzCA,sD;AACA,+B;AACA,mC;;AAEA,uC;AACA,gB;;AAEA,kB;AACA,oC;AACA,oB;AACA,8B;AACA,wB;AACA,mB;;AAEA,mB;;AAEA,kC;AACA,4B;;AAEA,kC;;AAEA,yB;AACA,+B;AACA,oD;AACA,I;;AAEA,oH;AACA,uE;;AAEA,iD;AACA,2B;AACA,I;AACA,E;AACA,yF;AACA,sF;AACA,I;;AAEA,yC;AACA,gC;AACA,qC;AACA,2B;;AAEA,gD;AACA,4E;AACA,wB;AACA,8B;;AAEA,2B;AACA,yB;AACA,6B;AACA,qG;AACA,gD;AACA,qD;AACA,oD;AACA,gD;AACA,W;AACA,S;AACA,e;AACA,K;;AAEA,mC;AACA,uD;AACA,yB;AACA,8C;AACA,4D;AACA,e;AACA,4C;AACA,O;AACA,K;;AAEA,mB;AACA,wD;AACA,gC;AACA,kD;AACA,6B;AACA,uB;AACA,6B;AACA,oC;AACA,oD;;AAEA,mD;AACA,oH;AACA,iC;AACA,uB;AACA,iD;AACA,6E;AACA,oC;AACA,2B;AACA,oE;AACA,S;AACA,O;AACA,0C;AACA,4C;AACA,M;AACA,kD;AACA,4D;AACA,uE;AACA,O;;AAEA,a;AACA,I;AACA,0B;;AAEA,wC;AACA,iC;AACA,sC;AACA,mD;AACA,O;AACA,4B;AACA,gB;AACA,G;AACA,E;;AAEA,iC;;;;;;;;;;;;;;;;;;ACjHA,2D;AACA,iB;AACA,a;AACA,iB;AACA,O;AACA,c;AACA,iB;AACA,K;AACA,I;;AAEA,qC;AACA,mC;AACA,yE;AACA,I;;AAEA,sC;AACA,oC;AACA,0E;AACA,I;;AAEA,uE;AACA,4B;AACA,qD;AACA,kD;AACA,I;AACA,8B;AACA,oC;AACA,gB;AACA,uE;AACA,2C;AACA,mC;AACA,oD;AACA,S;AACA,sB;AACA,c;AACA,yB;AACA,O;AACA,Y;AACA,oB;AACA,K;AACA,M;AACA,C","sourcesContent":["function _EV() {\n  var self = this;\n  var handlers = {};\n\n  self.emit = function emit(event) {\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    if(handlers[event]) {\n      for(var lc=0; lc<handlers[event].length; lc++) {\n        var handler = handlers[event][lc];\n        handler.apply(this, args);\n      }\n    }\n  };\n\n  self.on = function on(event, callback) {\n    if(!handlers[event]) {\n      handlers[event] = [];\n    }\n    handlers[event].push(callback);\n  };\n\n  self.once = function once(event, callback) {\n    self.on(event, function onetimeCallback() {\n      callback.apply(this, arguments);\n      self.removeListener(event, onetimeCallback);\n    });\n  };\n\n  self.removeListener = function removeListener(event, callback) {\n    if(handlers[event]) {\n      var index = handlers[event].indexOf(callback);\n      handlers[event].splice(index, 1);\n    }\n  };\n\n  self.removeAllListeners = function removeAllListeners(event) {\n    handlers[event] = undefined;\n  };\n}\n\nEV = _EV;","var EventEmitter = Npm.require('events').EventEmitter;\nvar util = Npm.require('util');\nvar Fibers = Npm.require('fibers');\n\nMeteor.Stream = function Stream(name) {\n  EV.call(this);\n\n  var self = this;\n  var streamName = 'stream-' + name;\n  var allowFunction;\n  var allowResultCache = true;\n  var allowResults = {};\n  var filters = [];\n\n  self.name = name;\n\n  var events = new EventEmitter();\n  events.setMaxListeners(0);\n\n  var disconnectEvents = new EV();\n\n  self._emit = self.emit;\n  self.emit = function emit() {\n    self.emitToSubscriptions(arguments, null, null);\n  };\n\n  var defaultResult =  (typeof(Package) == 'object' && Package.insecure)? true: Meteor.Collection.insecure === true;\n  self.permissions = new Meteor.Stream.Permission(defaultResult, true);\n\n  self.addFilter = function addFilter(callback) {\n    filters.push(callback);\n  };\n  \n  self.emitToSubscriptions = function emitToSubscriptions(args, subscriptionId, userId) {\n    events.emit('item', {args: args, userId: userId, subscriptionId: subscriptionId});\n  };\n\n  Meteor.publish(streamName, function() {\n    check(arguments, Match.Any);\n    var subscriptionId = Random.id();\n    var publication = this;\n\n    //send subscription id as the first document\n    publication.added(streamName, subscriptionId, {type: 'subscriptionId'});\n    publication.ready();\n    events.on('item', onItem);\n\n    function onItem(item) {\n      Fibers(function() {\n        var id = Random.id();\n        if(self.permissions.checkPermission('read', subscriptionId, publication.userId, item.args)) {\n          //do not send again this to the sender\n          if(subscriptionId != item.subscriptionId) {\n            publication.added(streamName, id, item);\n            publication.removed(streamName, id);\n          }\n        }\n      }).run();\n    }\n\n    publication.onStop(function() {\n      //trigger related onDisconnect handlers if exists\n      Fibers(function() {\n        disconnectEvents.emit(subscriptionId);\n        disconnectEvents.removeAllListeners(subscriptionId);\n      }).run();\n      events.removeListener('item', onItem);\n    });\n  });\n\n  var methods = {};\n  methods[streamName] = function(subscriptionId, args) {\n    check(arguments, Match.Any);\n    //in order to send this to the server callback\n    var userId = this.userId;\n    Fibers(function() {\n      var methodContext = {};\n      methodContext.userId = userId;\n      methodContext.subscriptionId = subscriptionId;\n\n      //in order to send this to the serve callback\n      methodContext.allowed = self.permissions.checkPermission('write', subscriptionId, methodContext.userId, args);\n      if(methodContext.allowed) {\n        //apply filters\n        args = applyFilters(args, methodContext);\n        self.emitToSubscriptions(args, subscriptionId, methodContext.userId);\n        //send to firehose if exists\n        if(self.firehose) {\n          self.firehose(args, subscriptionId, methodContext.userId);\n        }\n      }\n      //need to send this to server always\n      self._emit.apply(methodContext, args);\n      \n      //register onDisconnect handlers if provided\n      if(typeof(methodContext.onDisconnect) == 'function') {\n        disconnectEvents.on(subscriptionId, methodContext.onDisconnect)\n      }\n\n    }).run();\n  };\n  Meteor.methods(methods);\n\n  function applyFilters(args, context) {\n    var eventName = args.shift();\n    filters.forEach(function(filter) {\n      args = filter.call(context, eventName, args);\n    });\n    args.unshift(eventName);\n    return args;\n  }\n};\n\nutil.inherits(Meteor.Stream, EV);","Meteor.Stream.Permission = function (acceptAll, cacheAll) {\n  var options = {\n    \"read\": {\n      results: {}\n    }, \n    \"write\": {\n      results: {}\n    }\n  };\n\n  this.read = function(func, cache) {\n    options['read']['func'] = func;\n    options['read']['doCache'] = (cache === undefined)? cacheAll: cache; \n  };\n\n  this.write = function(func, cache) {\n    options['write']['func'] = func;\n    options['write']['doCache'] = (cache === undefined)? cacheAll: cache; \n  };\n\n  this.checkPermission = function(type, subscriptionId, userId, args) {\n    var eventName = args[0];\n    var namespace = subscriptionId + '-' + eventName;\n    var result = options[type].results[namespace];\n    \n    if(result === undefined) {\n      var func = options[type].func;\n      if(func) {\n        var context = {subscriptionId: subscriptionId, userId: userId};\n        result = func.apply(context, args);\n        if(options[type].doCache) {\n          options[type].results[namespace] = result;\n        }\n        return result;\n      } else {\n        return acceptAll;\n      }\n    } else {\n      return result;\n    }\n  };  \n}\n"]}