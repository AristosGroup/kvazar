{"version":3,"file":"/packages/application-configuration.js","sources":["application-configuration/config.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,0C;;AAEA,e;;;AAGA,2C;AACA,+E;AACA,gB;AACA,G;AACA,qF;AACA,G;;AAEA,mC;;AAEA,6B;AACA,U;AACA,0E;AACA,e;AACA,a;AACA,oC;;AAEA,4B;AACA,c;AACA,gD;AACA,uB;AACA,O;AACA,kD;AACA,uB;AACA,O;AACA,uD;AACA,8B;AACA,G;AACA,G;;AAEA,+E;AACA,U;AACA,2C;AACA,0B;AACA,oB;AACA,E;;AAEA,oB;;AAEA,K;AACA,+B;AACA,yD;AACA,U;AACA,iB;AACA,S;AACA,wC;AACA,2D;AACA,O;AACA,iB;AACA,0D;AACA,K;AACA,uB;AACA,yB;AACA,iB;AACA,2B;AACA,qC;AACA,4C;AACA,S;AACA,O;AACA,M;AACA,G;AACA,a;AACA,sE;AACA,E;;AAEA,sC;AACA,mD;AACA,2B;AACA,G;AACA,mB;AACA,yD;AACA,Y;AACA,wB;AACA,yD;AACA,E;;AAEA,gE;AACA,mF;AACA,0E;AACA,kB;AACA,mF;AACA,gF;AACA,2D;AACA,+E;AACA,8C;AACA,wB;AACA,6C;AACA,4F;AACA,oC;AACA,oD;AACA,4B;AACA,K;AACA,I;AACA,gB;AACA,8B;;AAEA,6E;AACA,U;AACA,6B;AACA,6E;AACA,6C;AACA,4B;AACA,iE;AACA,kC;AACA,mC;AACA,O;AACA,sB;AACA,K;;AAEA,U;AACA,uB;AACA,sB;AACA,uB;AACA,K;AACA,I;AACA,E;;;AAGA,gE;AACA,c;AACA,6E;AACA,6C;AACA,4B;AACA,mD;AACA,uD;AACA,uB;AACA,wB;AACA,O;AACA,G;;AAEA,E","sourcesContent":["var Future = Npm.require(\"fibers/future\");\n\nAppConfig = {};\n\n\nAppConfig.findGalaxy = _.once(function () {\n  if (!('GALAXY' in process.env || 'ULTRAWORLD_DDP_ENDPOINT' in process.env)) {\n    return null;\n  }\n  return Follower.connect(process.env.ULTRAWORLD_DDP_ENDPOINT || process.env.GALAXY);\n});\n\nvar ultra = AppConfig.findGalaxy();\n\nvar subFuture = new Future();\nif (ultra)\n  ultra.subscribe(\"oneApp\", process.env.GALAXY_APP, subFuture.resolver());\nvar OneAppApps;\nvar Services;\nvar collectionFuture = new Future();\n\nMeteor.startup(function () {\n  if (ultra) {\n    OneAppApps = new Meteor.Collection(\"apps\", {\n      connection: ultra\n    });\n    Services = new Meteor.Collection('services', {\n      connection: ultra\n    });\n    // allow us to block on the collections being ready\n    collectionFuture.return();\n  }\n});\n\n// XXX: Remove this once we allow the same collection to be new'd from multiple\n// places.\nAppConfig._getAppCollection = function () {\n  collectionFuture.wait();\n  return OneAppApps;\n};\n\nvar staticAppConfig;\n\ntry {\n  if (process.env.APP_CONFIG) {\n    staticAppConfig = JSON.parse(process.env.APP_CONFIG);\n  } else {\n    var settings;\n    try {\n      if (process.env.METEOR_SETTINGS) {\n        settings = JSON.parse(process.env.METEOR_SETTINGS);\n      }\n    } catch (e) {\n      Log.warn(\"Could not parse METEOR_SETTINGS as JSON\");\n    }\n    staticAppConfig = {\n      settings: settings,\n      packages: {\n        'mongo-livedata': {\n          url: process.env.MONGO_URL,\n          oplog: process.env.MONGO_OPLOG_URL\n        }\n      }\n    };\n  }\n} catch (e) {\n  Log.warn(\"Could not parse initial APP_CONFIG environment variable\");\n};\n\nAppConfig.getAppConfig = function () {\n  if (!subFuture.isResolved() && staticAppConfig) {\n    return staticAppConfig;\n  }\n  subFuture.wait();\n  var myApp = OneAppApps.findOne(process.env.GALAXY_APP);\n  if (myApp)\n    return myApp.config;\n  throw new Error(\"there is no app config for this app\");\n};\n\nAppConfig.configurePackage = function (packageName, configure) {\n  var appConfig = AppConfig.getAppConfig(); // Will either be based in the env var,\n                                         // or wait for galaxy to connect.\n  var lastConfig =\n        (appConfig && appConfig.packages && appConfig.packages[packageName]) || {};\n  // Always call the configure callback \"soon\" even if the initial configuration\n  // is empty (synchronously, though deferred would be OK).\n  // XXX make sure that all callers of configurePackage deal well with multiple\n  // callback invocations!  eg, email does not\n  configure(lastConfig);\n  var configureIfDifferent = function (app) {\n    if (!EJSON.equals(app.config && app.config.packages && app.config.packages[packageName],\n                      lastConfig)) {\n      lastConfig = app.config.packages[packageName];\n      configure(lastConfig);\n    }\n  };\n  var subHandle;\n  var observed = new Future();\n\n  // This is not required to finish, so defer it so it doesn't block anything\n  // else.\n  Meteor.defer( function () {\n    // there's a Meteor.startup() that produces the various collections, make\n    // sure it runs first before we continue.\n    collectionFuture.wait();\n    subHandle = OneAppApps.find(process.env.GALAXY_APP).observe({\n      added: configureIfDifferent,\n      changed: configureIfDifferent\n    });\n    observed.return();\n  });\n\n  return {\n    stop: function () {\n      observed.wait();\n      subHandle.stop();\n    }\n  };\n};\n\n\nAppConfig.configureService = function (serviceName, configure) {\n  if (ultra) {\n    // there's a Meteor.startup() that produces the various collections, make\n    // sure it runs first before we continue.\n    collectionFuture.wait();\n    ultra.subscribe('servicesByName', serviceName);\n    return Services.find({name: serviceName}).observe({\n      added: configure,\n      changed: configure\n    });\n  }\n\n};\n"]}