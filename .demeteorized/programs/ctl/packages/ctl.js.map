{"version":3,"file":"/packages/ctl.js","sources":["ctl/ctl.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA,mB;AACA,e;AACA,yB;AACA,oC;AACA,kB;AACA,oC;AACA,qB;;AAEA,oC;AACA,G;AACA,G;;AAEA,0C;AACA,6B;AACA,gC;AACA,4E;AACA,sC;AACA,6D;AACA,2C;AACA,Q;AACA,oB;AACA,K;AACA,gB;AACA,E;;;;AAIA,gC;AACA,yC;AACA,yB;AACA,4B;AACA,c;AACA,gF;AACA,oB;AACA,M;AACA,oB;AACA,G;AACA,kC;AACA,6D;AACA,uE;AACA,G;AACA,0D;AACA,+D;AACA,E;;AAEA,mB;AACA,gB;AACA,yB;AACA,gB;AACA,G;;;AAGA,mB;AACA,oB;AACA,0C;AACA,gB;AACA,G;;AAEA,gC;AACA,yC;AACA,yB;AACA,2B;AACA,c;AACA,4E;AACA,8B;AACA,M;AACA,oB;AACA,G;;AAEA,2E;AACA,oB;AACA,8B;AACA,+D;AACA,+B;AACA,4B;AACA,kC;AACA,a;AACA,sB;AACA,iB;AACA,a;AACA,mC;AACA,K;AACA,iC;AACA,E;;AAEA,mB;AACA,e;AACA,wB;AACA,e;AACA,G;;;AAGA,mB;AACA,sB;AACA,2C;AACA,e;AACA,G;;AAEA,mB;AACA,gB;AACA,qB;AACA,yB;AACA,wE;AACA,2B;AACA,wC;AACA,O;AACA,8E;AACA,kB;AACA,E;AACA,sB;AACA,K;;AAEA,+C;AACA,wC;AACA,e;AACA,uE;AACA,wB;AACA,O;AACA,oD;AACA,O;;AAEA,iC;AACA,kC;AACA,4D;AACA,mC;AACA,kB;AACA,6E;AACA,c;AACA,0B;AACA,uC;AACA,S;AACA,S;AACA,+C;AACA,uB;AACA,e;AACA,iE;AACA,oC;AACA,yB;AACA,8E;AACA,+B;AACA,Y;AACA,S;AACA,O;AACA,G;AACA,G;;AAEA,wB;AACA,wB;AACA,E","sourcesContent":["Ctl.Commands.push({\n  name: \"help\",\n  func: function (argv) {\n    if (!argv._.length || argv.help)\n      Ctl.usage();\n    var cmd = argv._.splice(0,1)[0];\n    argv.help = true;\n\n    Ctl.findCommand(cmd).func(argv);\n  }\n});\n\nvar mergeObjects = function (obj1, obj2) {\n  var result = _.clone(obj1);\n  _.each(obj2, function (v, k) {\n    // If both objects have an object at this key, then merge those objects.\n    // Otherwise, choose obj2's value.\n    if ((v instanceof Object) && (obj1[k] instanceof Object))\n      result[k] = mergeObjects(v, obj1[k]);\n    else\n      result[k] = v;\n  });\n  return result;\n};\n\n\n\nvar startFun = function (argv) {\n  if (argv.help || argv._.length !== 0) {\n    process.stderr.write(\n      \"Usage: ctl start\\n\" +\n        \"\\n\" +\n        \"Starts the app. For now, this just means that it runs the 'server'\\n\" +\n        \"program.\\n\"\n    );\n    process.exit(1);\n  }\n  if (Ctl.hasProgram(\"console\")) {\n    console.log(\"starting console for app\", Ctl.myAppName());\n    Ctl.startServerlikeProgramIfNotPresent(\"console\", [\"admin\"], true);\n  }\n  console.log(\"starting server for app\", Ctl.myAppName());\n  Ctl.startServerlikeProgramIfNotPresent(\"server\", [\"runner\"]);\n};\n\nCtl.Commands.push({\n  name: \"start\",\n  help: \"Start this app\",\n  func: startFun\n});\n\n\nCtl.Commands.push({\n  name: \"endUpdate\",\n  help: \"Start this app to end an update\",\n  func: startFun\n});\n\nvar stopFun =  function (argv) {\n  if (argv.help || argv._.length !== 0) {\n    process.stderr.write(\n      \"Usage: ctl stop\\n\" +\n        \"\\n\" +\n        \"Stops the app. For now, this just means that it kills all jobs\\n\" +\n        \"other than itself.\\n\"\n    );\n    process.exit(1);\n  }\n\n  // Get all jobs (other than this job: don't commit suicide!) that are not\n  // already killed.\n  var jobs = Ctl.getJobsByApp(\n    Ctl.myAppName(), {_id: {$ne: Ctl.myJobId()}, done: false});\n  jobs.forEach(function (job) {\n    // Don't commit suicide.\n    if (job._id === Ctl.myJobId())\n      return;\n    // It's dead, Jim.\n    if (job.done)\n      return;\n    Ctl.kill(job.program, job._id);\n  });\n  console.log(\"Server stopped.\");\n};\n\nCtl.Commands.push({\n  name: \"stop\",\n  help: \"Stop this app\",\n  func: stopFun\n});\n\n\nCtl.Commands.push({\n  name: \"beginUpdate\",\n  help: \"Stop this app to begin an update\",\n  func: stopFun\n});\n\nCtl.Commands.push({\n  name: \"scale\",\n  help: \"Scale jobs\",\n  func: function (argv) {\n    if (argv.help || argv._.length === 0 || _.contains(argv._, 'ctl')) {\n      process.stderr.write(\n\"Usage: ctl scale program1=n [...] \\n\" +\n \"\\n\" +\n\"Scales some programs. Runs or kills jobs until there are n non-done jobs\\n\" +\n\"in that state.\\n\"\n);\n      process.exit(1);\n    }\n\n    var scales = _.map(argv._, function (arg) {\n      var m = arg.match(/^(.+)=(\\d+)$/);\n      if (!m) {\n        console.log(\"Bad scaling argument; should be program=number.\");\n        process.exit(1);\n      }\n      return {program: m[1], scale: parseInt(m[2])};\n    });\n\n    _.each(scales, function (s) {\n      var jobs = Ctl.getJobsByApp(\n        Ctl.myAppName(), {program: s.program, done: false});\n      jobs.forEach(function (job) {\n        --s.scale;\n        // Is this an extraneous job, more than the number that we need? Kill\n        // it!\n        if (s.scale < 0) {\n          Ctl.kill(s.program, job._id);\n        }\n      });\n      // Now start any jobs that are necessary.\n      if (s.scale <= 0)\n        return;\n      console.log(\"Starting %d jobs for %s\", s.scale, s.program);\n      _.times(s.scale, function () {\n        // XXX args? env?\n        Ctl.prettyCall(Ctl.findGalaxy(), 'run', [Ctl.myAppName(), s.program, {\n          exitPolicy: 'restart'\n        }]);\n      });\n    });\n  }\n});\n\nmain = function (argv) {\n  return Ctl.main(argv);\n};\n"]}